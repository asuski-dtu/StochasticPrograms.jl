var documenterSearchIndex = {"docs":
[{"location":"manual/data/#Stochastic-data","page":"Stochastic data","title":"Stochastic data","text":"","category":"section"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Decoupling data design and model design is a fundamental principle in StochasticPrograms. This decoupling is achieved through data injection. By data we mean parameters in an optimization problem. In StochasticPrograms, this data is either deterministic and related to a specific stage, or uncertain and related to a specific scenario.","category":"page"},{"location":"manual/data/#Stage-data","page":"Stochastic data","title":"Stage data","text":"","category":"section"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Stage data is related to parameters that always appear in the first or second stage of a stochastic program. These parameters are deterministic and are the same across all scenarios. Such parameters are conviently included in stochastic models using @parameters. To showcase, we consider a minimal stochastic program:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"DeclareMathOperator*maximizemaximize\nbeginaligned\n maximize_x in mathbbR  quad x + operatornamemathbbE_omega leftQ(x xi(omega))right \n textst  quad l_1 leq x leq u_1\nendaligned","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"where","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"beginaligned\n Q(x xi(omega)) = max_y in mathbbR  quad q_omega y \n textst  quad y + x leq U \n  quad l_2 leq y leq u_2\nendaligned","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"and the stochastic variable","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"  xi(omega) = q_omega","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"takes on the value 1 or -1 with equal probability. Here, the first stage contains the two parameters: l_1 and u_1. The second stage contains the three scenario-independent parameters: U, l_2, and u_2. The following defines this problem in StochasticPrograms, with some chosen deault parameter values:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\nusing GLPKMathProgInterface\n\nsm = @stochastic_model begin\n    @stage 1 begin\n        @parameters begin\n            l₁ = -1.\n            u₁ = 1.\n        end\n        @variable(model, l₁ <= x <= u₁)\n        @objective(model, Max, x)\n    end\n    @stage 2 begin\n        @parameters begin\n            U = 2.\n            l₂ = -1.\n            u₂ = 1.\n        end\n        @decision x\n        @uncertain q\n        @variable(model, l₂ <= y <= u₂)\n        @objective(model, Max, q*y)\n        @constraint(model, y + x <= U)\n    end\nend\n\nξ₁ = Scenario(q = 1., probability = 0.5)\nξ₂ = Scenario(q = -1., probability = 0.5)\n\nsp = instantiate(sm, [ξ₁,ξ₂])\n\nprint(sp)\n\nprint(\"VRP = $(VRP(sp, solver = GLPKSolverLP()))\")","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Now, we can investigate the impact of the stage parameters by changing them slightly and reinstantiate the problem. This is achieved by supplying the new parameter values as keyword arguments to instantiate:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"sp = instantiate(sm, [ξ₁,ξ₂], l₁ = -2., u₁ = 2., U = 2., l₂ = -0.5, u₂ = 0.5)\n\nprint(sp)\n\nprint(\"VRP = $(VRP(sp, solver = GLPKSolverLP()))\")","category":"page"},{"location":"manual/data/#Scenario-data","page":"Stochastic data","title":"Scenario data","text":"","category":"section"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Any uncertain parameter in the second stage of a stochastic program should be included in some predefined AbstractScenario type. Hence, all uncertain parameters in a stochastic program must be identified before defining the models. In brief, StochasticPrograms demands two functions from this abstraction. The discrete probability of a given AbstractScenario occurring should be returned from probability. Also, the expected scenario out of a collection of given AbstractScenarios should be returned by expected. The predefined Scenario type adheres to this abstraction and is the recommended option when uncertain variables is a set of scalar values, as exemplified in the Quick start.","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"In addition, StochasticPrograms provides a convenience macro, @scenario, for creating scenario types that also adhere to the scenario abstraction. The following is an alternative way to define a scenario structure for the simple problem introduced in the Quick start:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\n@scenario SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Now, xi_1 and xi_2 can be created through:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"ξ₁ = SimpleScenario(-24.0, -28.0, 500.0, 100.0, probability = 0.4)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"and","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"ξ₂ = SimpleScenario(-28.0, -32.0, 300.0, 300.0, probability = 0.6)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"The define SimpleScenarios automatically have the [AbstractScenario] functionality. For example, we can check the discrete probability of a given scenario occuring:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"probability(ξ₁)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Moreover, we can form the expected scenario out of a given set:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"ξ̄ = expected([ξ₁, ξ₂])","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"There are some caveats to note. First, the autogenerated requires an additive zero element of the introduced scenario type. For simple numeric types this is autogenerated as well. However, say that we want to extend the above scenario with some vector parameter of size 2:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\n@scenario ExampleScenario = begin\n    X::Float64\n    Y::Vector{Float64}\nend","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"In this case, we must provide an implementation of zero using @zero:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\n@scenario ExampleScenario = begin\n    X::Float64\n    Y::Vector{Float64}\n\n    @zero begin\n        return ExampleScenario(0.0, [0.0, 0.0])\n    end\nend\n\ns₁ = ExampleScenario(1., ones(2), probability = 0.5)\ns₂ = ExampleScenario(5., -ones(2), probability = 0.5)\n\nprintln(\"Probability of s₁: $(probability(s₁))\")\n\ns = expected([s₁, s₂])\n\nprintln(\"Expectation over s₁ and s₂: $s\")\nprintln(\"Expectated X: $(s.scenario.X)\")\nprintln(\"Expectated Y: $(s.scenario.Y)\")","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Another caveat is that the expected function can only be auto generated for fields that support addition and scalar multiplication with Float64. Consider:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\n@scenario ExampleScenario = begin\n    X::Float64\n    Y::Vector{Float64}\n    Z::Int\n\n    @zero begin\n        return ExampleScenario(0.0, [0.0, 0.0], 0)\n    end\nend","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Again, the solution is to provide an implementation of expected, this time using @expectation:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\n@scenario ExampleScenario = begin\n    X::Float64\n    Y::Vector{Float64}\n    Z::Int\n\n    @zero begin\n        return ExampleScenario(0.0, [0.0, 0.0], 0)\n    end\n\n    @expectation begin\n        X = sum([probability(s)*s.X for s in scenarios])\n        Y = sum([probability(s)*s.Y for s in scenarios])\n        Z = sum([round(Int, probability(s)*s.Z) for s in scenarios])\n        return ExampleScenario(X, Y, Z)\n    end\nend\n\ns₁ = ExampleScenario(1., ones(2), 1, probability = 0.5)\ns₂ = ExampleScenario(5., -ones(2), -1, probability = 0.5)\n\nprintln(\"Probability of s₁: $(probability(s₁))\")\n\ns = expected([s₁, s₂])\n\nprintln(\"Expectation over s₁ and s₂: $s\")\nprintln(\"Expectated X: $(s.scenario.X)\")\nprintln(\"Expectated Y: $(s.scenario.Y)\")\nprintln(\"Expectated Z: $(s.scenario.Z)\")","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"For most problems, @scenario will probably be adequate. Otherwise consider defining Custom scenarios.","category":"page"},{"location":"manual/data/#Sampling","page":"Stochastic data","title":"Sampling","text":"","category":"section"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using Random\nRandom.seed!(1)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Typically, we do not have exact knowledge of all possible future scenarios. However, we often have access to some model of the uncertainty. For example, scenarios could originate from:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"A stochastic variable with known distribution\nA time series fitted to data\nA nerual network prediction","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Even if the exact scenario distribution is unknown, or not all possible scenarios are available, we can still formulate a stochastic program that approximates the model we wish to formulate. This is achieved through a technique called sampled average approximation, which is based on sampling. The idea is to sample a large number n of scenarios with equal probability frac1n and then use them to generate and solve a stochastic program. By the law of large numbers, the result will converge with probability 1 to the \"true\" solution with increasing n.","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"StochasticPrograms accepts AbstractSampler objects in place of AbstractScenario. However, an AbstractSampler is always linked to some underlying AbstractScenario type, which is reflected in the resulting stochastic program as well.","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"The most basic sampler is the included Sampler, which is used to sample basic Scenarios. Consider","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\nsampler = Sampler() do\n    return Scenario(q₁ = -24.0 + randn(), q₂ = -28.0 + randn(), d₁ = 500.0 + randn(), d₂ = 100 + randn(), probability = rand())\nend\n\nsampler()","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Samplers can also be conviniently created using @sampler. We can define a simple scenario type and a simple sampler as follows:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\n@scenario ExampleScenario = begin\n    w::Float64\nend\n\n@sampler ExampleSampler = begin\n    w::Float64\n\n    ExampleSampler(w::AbstractFloat) = new(w)\n\n    @sample ExampleScenario begin\n        w = sampler.w\n        return ExampleScenario(w*randn(), probability = rand())\n    end\nend","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"This creates a new AbstractSampler type called ExampleSampler, which samples ExampleScenarios. Now, we can create a sampler object and sample a scenario","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"sampler = ExampleSampler(2.)\n\nξ = sampler()\n\nprintln(ξ)\nprintln(\"ξ: $(ξ.w)\")","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Now, lets create a stochastic model using the ExampleScenario type:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"sm = @stochastic_model begin\n    @stage 1 begin\n        @variable(model, x >= 0)\n        @objective(model, Min, x)\n    end\n    @stage 2 begin\n        @decision x\n        @uncertain w from ExampleScenario\n        @variable(model, y)\n        @objective(model, Min, y)\n        @constraint(model, y + x == w)\n    end\nend","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Now, we can sample 5 scenarios using the first sampler to generate 5 subproblems:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"sp = sample(sm, sampler, 5)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Printing yields:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"print(sp)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Sampled stochastic programs are solved as usual:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using GLPKMathProgInterface\n\noptimize!(sp, solver = GLPKSolverLP())\n\nprintln(\"optimal decision: $(optimal_decision(sp))\")\nprintln(\"optimal value: $(optimal_value(sp))\")","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Again, if the functionality offered by @sampler is not adequate, consider Custom scenarios.","category":"page"},{"location":"manual/data/#Custom-scenarios","page":"Stochastic data","title":"Custom scenarios","text":"","category":"section"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using Random\nRandom.seed!(1)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"More complex scenario designs are probably not implementable using @scenario. However, it is still possible to create a custom scenario type as long as:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"The type is a subtype of AbstractScenario\nThe type implements probability\nThe type implements expected, which should return an additive zero element if given an empty array","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"The restriction on expected is there to support taking expectations in a distributed environment. We are also free to define custom sampler objects, as long as:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"The sampler type is a subtype of AbstractSampler\nThe sampler type implements a functor call that performs the sampling","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"See the Continuous scenario distribution for an example of custom scenario/sampler implementations.","category":"page"},{"location":"library/crash/#Crash","page":"Crash","title":"Crash","text":"","category":"section"},{"location":"library/crash/","page":"Crash","title":"Crash","text":"Documentation for StochasticPrograms.jl's crash methods, for use in structured solvers and sample-based solvers.","category":"page"},{"location":"library/crash/#Index","page":"Crash","title":"Index","text":"","category":"section"},{"location":"library/crash/","page":"Crash","title":"Crash","text":"Pages = [\"crash.md\"]","category":"page"},{"location":"library/crash/#Crash-methods","page":"Crash","title":"Crash methods","text":"","category":"section"},{"location":"library/crash/","page":"Crash","title":"Crash","text":"Modules = [Crash]\nPages   = [\"crash.jl\"]","category":"page"},{"location":"library/crash/#StochasticPrograms.Crash","page":"Crash","title":"StochasticPrograms.Crash","text":"Crash\n\nCollection of crash methods used to generate initial decisions in structured algorithms.\n\n...\n\nAvailable crash methods\n\nNone\nEVP\nScenario\nCustom\n\n...\n\nExamples\n\nThe following solves a stochastic program sp created in StochasticPrograms.jl using an L-shaped algorithm with trust-region and Clp as an lpsolver and by generating an initial decision with the EVP crash.\n\njulia> optimize!(sp, solver = LShapedSolver(GLPKSolverLP(), crash=Crash.EVP(), regularize = TrustRegion()))\nL-Shaped Gap  Time: 0:00:00 (8 iterations)\n  Objective:       -855.8333333333339\n  Gap:             0.0\n  Number of cuts:  4\n  Iterations:      8\n:Optimal\n\n\n\n\n\n","category":"module"},{"location":"library/crash/#StochasticPrograms.Crash.Custom","page":"Crash","title":"StochasticPrograms.Crash.Custom","text":"Custom(x₀)\n\nUse the user-supplied x₀ as initial decision.\n\n\n\n\n\n","category":"type"},{"location":"library/crash/#StochasticPrograms.Crash.EVP","page":"Crash","title":"StochasticPrograms.Crash.EVP","text":"EVP\n\nSolve the expected value problem corresponding to the stochastic program and use the expected value solution as initial decision.\n\n\n\n\n\n","category":"type"},{"location":"library/crash/#StochasticPrograms.Crash.None","page":"Crash","title":"StochasticPrograms.Crash.None","text":"None\n\nRandomize the initial decision (default).\n\n\n\n\n\n","category":"type"},{"location":"library/crash/#StochasticPrograms.Crash.Scenario","page":"Crash","title":"StochasticPrograms.Crash.Scenario","text":"Scenario\n\nSolve the wait-and-see problem corresponding a supplied scenario and use the optimal solution as initial decision.\n\n\n\n\n\n","category":"type"},{"location":"manual/quickstart/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"manual/quickstart/#Installation","page":"Quick start","title":"Installation","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"StochasticPrograms is installed as follows:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"pkg> add StochasticPrograms","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Afterwards, the functionality can be made available in a module or REPL through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"using StochasticPrograms","category":"page"},{"location":"manual/quickstart/#Stochastic-programs","page":"Quick start","title":"Stochastic programs","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Consider some probability space (OmegamathcalFpi) where Omega is a sample space, mathcalF is a sigma-algebra over Omega and pi mathcalF to 01 is a probability measure. Let xi(omega) Omega to mathbbR^N be some random variable on Omega with finite second moments. A two-stage linear stochastic program has the following mathematical representation:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"DeclareMathOperator*minimizeminimize\nbeginaligned\n minimize_x in mathbbR^n  quad c^T x + operatornamemathbbE_omega leftQ(xxi(omega))right \n textst  quad Ax = b \n  quad x geq 0\nendaligned","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"where","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"beginaligned\n    Q(xxi(omega)) = min_y in mathbbR^m  quad q_omega^T y \n    textst  quad T_omegax + Wy = h_omega \n     quad y geq 0\n  endaligned","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"If the sample space Omega is finite, stochastic program has a closed form that can be represented on a computer. Such functionality is provided by StochasticPrograms. If the sample space Omega is infinite, sampling techniques can be used to represent the stochastic program using finite instances generated using  sample.","category":"page"},{"location":"manual/quickstart/#A-simple-stochastic-program","page":"Quick start","title":"A simple stochastic program","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"To showcase the use of StochasticPrograms we will walk through a simple example. Consider the following stochastic program: (taken from Introduction to Stochastic Programming).","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"DeclareMathOperator*minimizeminimize\nbeginaligned\n minimize_x_1 x_2 in mathbbR  quad 100x_1 + 150x_2 + operatornamemathbbE_omega leftQ(x_1x_2xi(omega))right \n textst  quad x_1+x_2 leq 120 \n  quad x_1 geq 40 \n  quad x_2 geq 20\nendaligned","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"where","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"beginaligned\n Q(x_1x_2xi(omega)) = min_y_1y_2 in mathbbR  quad q_1(omega)y_1 + q_2(omega)y_2 \n textst  quad 6y_1+10y_2 leq 60x_1 \n  quad 8y_1 + 5y_2 leq 80x_2 \n  quad 0 leq y_1 leq d_1(omega) \n  quad 0 leq y_2 leq d_2(omega)\nendaligned","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and the stochastic variable","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"  xi(omega) = beginpmatrix\n     q_1(omega)  q_2(omega)  d_1(omega)  d_2(omega)\n  endpmatrix^T","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"takes on the value","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"  xi_1 = beginpmatrix\n    -24  -28  500  100\n  endpmatrix^T","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"with probability 04 and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"  xi_1 = beginpmatrix\n    -28  -32  300  300\n  endpmatrix^T","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"with probability 06. In the following, we consider how to model, analyze, and solve this stochastic program using StochasticPrograms. In many examples, a MathProgBase solver is required. Hence, we load the GLPK solver.","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"using GLPKMathProgInterface","category":"page"},{"location":"manual/quickstart/#Stochastic-model-definition","page":"Quick start","title":"Stochastic model definition","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"First, we define a stochastic model that describes the introduced stochastic program above.","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"simple_model = @stochastic_model begin\n    @stage 1 begin\n        @variable(model, x₁ >= 40)\n        @variable(model, x₂ >= 20)\n        @objective(model, Min, 100*x₁ + 150*x₂)\n        @constraint(model, x₁ + x₂ <= 120)\n    end\n    @stage 2 begin\n        @decision x₁ x₂\n        @uncertain q₁ q₂ d₁ d₂\n        @variable(model, 0 <= y₁ <= d₁)\n        @variable(model, 0 <= y₂ <= d₂)\n        @objective(model, Min, q₁*y₁ + q₂*y₂)\n        @constraint(model, 6*y₁ + 10*y₂ <= 60*x₁)\n        @constraint(model, 8*y₁ + 5*y₂ <= 80*x₂)\n    end\nend","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The optimization models in the first and second stage are defined using JuMP syntax inside @stage blocks. Every first-stage variable that occurs in the second stage model is annotated with @decision at the beginning of the definition. Moreover, the @uncertain annotation specifies that the variables q₁, q₂, d₁ and d₂ are uncertain. Instances of the uncertain variables will later be injected to create instances of the second stage model.","category":"page"},{"location":"manual/quickstart/#Instantiating-the-stochastic-program","page":"Quick start","title":"Instantiating the stochastic program","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Next, we create the two instances xi_1 and xi_2 of the random variable. For simple models this is conveniently achieved through the Scenario type. xi_1 and xi_2 can be created as follows:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"ξ₁ = Scenario(q₁ = -24.0, q₂ = -28.0, d₁ = 500.0, d₂ = 100.0, probability = 0.4)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"ξ₂ = Scenario(q₁ = -28.0, q₂ = -32.0, d₁ = 300.0, d₂ = 300.0, probability = 0.6)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"where the variable names should match those given in the @uncertain annotation. We are now ready to instantiate the stochastic program introduced above.","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"sp = instantiate(simple_model, [ξ₁, ξ₂], solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The above command creates an instance of the first stage model and second stage model instances for each of the supplied scenarios. The provided solver will be used internally when necessary. For clarity, we will still explicitly supply a solver when it is required. We can print the stochastic program and confirm that it indeed models the example recourse problem given above:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"print(sp)","category":"page"},{"location":"manual/quickstart/#Deterministically-equivalent-problem","page":"Quick start","title":"Deterministically equivalent problem","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Since the example problem is small it is straightforward to work out the extended form:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"beginaligned\n minimize_x_1 x_2 y_11 y_21 y_12 y_22 in mathbbR  quad 100x_1 + 150x_2 - 96y_11 - 112y_21 - 168y_12 - 192y_22  \n textst  quad x_1 + x_2 leq 120 \n  quad 6 y_11 + 10 y_21 leq 60 x_1 \n  quad 8 y_11 + 5 y_21 leq 80 x_2 \n  quad 6 y_12 + 10 y_22 leq 60 x_1 \n  quad 8 y_12 + 5 y_22 leq 80 x_2 \n  quad x_1 geq 40 \n  quad x_2 geq 20 \n  quad 0 leq y_11 leq 500 \n  quad 0 leq y_21 leq 100 \n  quad 0 leq y_12 leq 300 \n  quad 0 leq y_22 leq 300\nendaligned","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"which is also commonly referred to as the deterministically equivalent problem. This construct is available in StochasticPrograms through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"dep = DEP(sp)\nprint(dep)","category":"page"},{"location":"manual/quickstart/#Sampled-average-approximation","page":"Quick start","title":"Sampled average approximation","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"In the above, the probability space consists of only two scenarios and the stochastic program can hence be represented in a closed form. If it instead holds that xi follows say a normal distribution, then it is no longer possible to represent the full stochastic program since this would require infinite scenarios. We then revert to sampling-based techniques. For example, let xi sim mathcalN(mu Sigma) with","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"mu = beginpmatrix\n -28 \n -32 \n 300 \n 300\nendpmatrix quad Sigma = beginpmatrix\n 2  05  0  0 \n 05  1  0  0 \n 0  0  50  20 \n 0  0  20  30\nendpmatrix","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"To approximate the resulting stochastic program in StochasticPrograms, we first create a sampler object capable of generating scenarios from this distribution. This is most conveniently achieved using the @sampler macro:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"@sampler SimpleSampler = begin\n    N::StochasticPrograms.MvNormal\n\n    SimpleSampler(μ, Σ) = new(StochasticPrograms.MvNormal(μ, Σ))\n\n    @sample Scenario begin\n        x = rand(sampler.N)\n        return Scenario(q₁ = x[1], q₂ = x[2], d₁ = x[3], d₂ = x[4], probability = StochasticPrograms.pdf(sampler.N, x))\n    end\nend\n\nμ = [-28, -32, 300, 300]\nΣ = [2 0.5 0 0\n     0.5 1 0 0\n     0 0 50 20\n     0 0 20 30]\n\nsampler = SimpleSampler(μ, Σ)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Now, we can use the same stochastic model created before and the created sampler object to generate a sampled approximation of the stochastic program. For now, we create a small sampled model of just 5 scenarios:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"sampled_sp = sample(simple_model, sampler, 5)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Typically, a large number of scenarios are required to accurately represent the stochastic program. We will consider this in more depth below. Let us first also print the sampled model:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"print(sampled_sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"In the subsequent discussions, note that sp represents the finite simple stochastic program with known closed form, simple_model contains the mathematical representation of the general stochastic model, and sampled_sp are approximated instances of the general model.","category":"page"},{"location":"manual/quickstart/#Evaluate-decisions","page":"Quick start","title":"Evaluate decisions","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Decision evaluation is an important concept in stochastic programming. The expected result of taking a given first-stage decision x is given by","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"V(x) = c^T x + operatornamemathbbE_omega leftQ(xxi(omega))right","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"If the sample space is finite, the above expressions has a closed form that is readily calculated. Consider the following first-stage decision:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"x = [40., 20.]","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The expected result of taking this decision in the simple finite model can be determined through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, x, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The supplied solver is used to solve all available second stage models, with fixed first-stage values. These outcome models can be built manually by supplying a scenario and the first-stage decision.","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"print(outcome_model(sp, x, ξ₁))","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Moreover, we can evaluate the result of the decision in a given scenario, i.e. solving a single outcome model, through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, x, ξ₁, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"If the sample space is infinite, or if the underlying random variable xi is continuous, a first-stage decision can only be evaluated in a stochastic sense. For example, note the result of evaluating the decision on the sampled model created above:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sampled_sp, x, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and compare it to the result of evaluating it on another SAA model of similar size:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"another_sp = sample(simple_model, sampler, 5)\nevaluate_decision(another_sp, x, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"which, if any, of these values should be a candidate for the true value of V(x)? A more precise result is obtained by evaluating the decision using a sampled-based approach. Such querys are instead made to the simple_model object by supplying an appropriate AbstractSampler and a desired confidence level. Consider:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(simple_model, x, sampler, solver = GLPKSolverLP(), confidence = 0.9)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The result is a 90% confidence interval around V(x). Consult evaluate_decision for the tweakable parameters that govern the resulting confidence interval.","category":"page"},{"location":"manual/quickstart/#Optimal-first-stage-decision","page":"Quick start","title":"Optimal first-stage decision","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The optimal first-stage decision is the decision that gives the best expected result over all available scenarios. This decision can be determined by solving the deterministically equivalent problem, by supplying a capable solver. Structure exploiting solvers are outlined in Structured solvers. In addition, it is possible to give a MathProgBase solver capable of solving linear programs. For example, we can solve sp with the GLPK solver as follows:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimize!(sp, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Internally, this generates and solves the extended form of sp. We can now inspect the optimal first-stage decision through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"x_opt = optimal_decision(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Moreover, the optimal value, i.e. the expected outcome of using the optimal decision, is acquired through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimal_value(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"which of course coincides with the result of evaluating the optimal decision:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, x_opt, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"This value is commonly referred to as the value of the recourse problem (VRP). We can also calculate it directly through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"VRP(sp, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"If the sample space is infinite, or if the underlying random variable xi is continuous, the value of the recourse problem can not be computed exactly. However, by supplying an AbstractSampler we can use sample-based techniques to compute a confidence interval around the true optimum:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"confidence_interval(simple_model, sampler, solver = GLPKSolverLP(), N = 200)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Similarly, a first-stage decision is only optimal in a stochastic sense. Such solutions can be obtained from running optimize! on the stochastic model object, supplying a sample-based solver. Sample-based solvers are also outlined in Structured solvers. StochasticPrograms includes the SAA solver, which approximately solves the stochastic program using sample average approximation (SAA). Emerging sampled instances are solved by a supplied AbstractStructuredSolver or by a MathProgBase solver through the extensive form. Consider the following:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"solution = optimize!(simple_model, sampler, solver = SAA(GLPKSolverLP()), confidence = 0.9)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The result is a StochasticSolution, which includes an optimal solution estimate as well as a confidence interval around the solution. The approximately optimal first-stage decision is obtained by","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"decision(solution)","category":"page"},{"location":"manual/quickstart/#Wait-and-see-models","page":"Quick start","title":"Wait-and-see models","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"If we assume that we know what the actual outcome will be, we would be interested in the optimal course of action in that scenario. This is the concept of wait-and-see models. For example if ξ₁ is believed to be the actual outcome, we can define a wait-and-see model as follows:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"ws = WS(sp, ξ₁)\nprint(ws)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The optimal first-stage decision in this scenario can be determined through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"x₁ = WS_decision(sp, ξ₁, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"We can evaluate this decision:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, x₁, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The outcome is of course worse than taking the optimal decision. However, it would perform better if ξ₁ is the actual outcome:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, x₁, ξ₁, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"as compared to:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, x_opt, ξ₁, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Another important concept is the wait-and-see model corresponding to the expected future scenario. This is referred to as the expected value problem and can be generated through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evp = EVP(sp)\nprint(evp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Internally, this generates the expected scenario out of the available scenarios and forms the respective wait-and-see model. The optimal first-stage decision associated with the expected value problem is conviently determined using","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"x̄ = EVP_decision(sp, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Again, we can evaluate this decision:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, x̄, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"This value is often referred to as the expected result of using the expected value solution (EEV), and is also available through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"EEV(sp, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/#Stochastic-performance","page":"Quick start","title":"Stochastic performance","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Finally, we consider some performance measures of the defined model. The expected value of perfect information is the difference between the value of the recourse problem and the expected result of having perfect knowledge. In other words, it involes solving the recourse problem as well as every wait-and-see model that can be formed from the available scenarios. We calculate it as follows:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"EVPI(sp, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The resulting value indicates the expected gain of having perfect information about future scenarios. Another concept is the value of the stochastic solution, which is the difference between the value of the recourse problem and the EEV. We calculate it as follows:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"VSS(sp, solver = GLPKSolverLP())","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The resulting value indicates the gain of including uncertainty in the model formulation.","category":"page"},{"location":"library/solverinterface/#Solver-interface","page":"Solver interface","title":"Solver interface","text":"","category":"section"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"Documentation for StochasticPrograms.jl's interface for structured solvers and sample-based solvers.","category":"page"},{"location":"library/solverinterface/#Index","page":"Solver interface","title":"Index","text":"","category":"section"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"Pages = [\"solverinterface.md\"]","category":"page"},{"location":"library/solverinterface/#Interface","page":"Solver interface","title":"Interface","text":"","category":"section"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"AbstractStructuredSolver\nAbstractStructuredModel\nAbstractSampledSolver\nAbstractSampledModel","category":"page"},{"location":"library/solverinterface/#StochasticPrograms.AbstractStructuredSolver","page":"Solver interface","title":"StochasticPrograms.AbstractStructuredSolver","text":"AbstractStructuredSolver\n\nAbstract supertype for structured solver interface objects.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.AbstractStructuredModel","page":"Solver interface","title":"StochasticPrograms.AbstractStructuredModel","text":"AbstractStructuredModel\n\nAbstract supertype for structured solver objects.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.AbstractSampledSolver","page":"Solver interface","title":"StochasticPrograms.AbstractSampledSolver","text":"AbstractSampledSolver\n\nAbstract supertype for sample-based solver interface objects.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.AbstractSampledModel","page":"Solver interface","title":"StochasticPrograms.AbstractSampledModel","text":"AbstractSampledModel\n\nAbstract supertype for sample-based solver objects.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"Modules = [StochasticPrograms]\nPages   = [\"spinterface.jl\"]","category":"page"},{"location":"library/solverinterface/#StochasticPrograms.SampledModel-Tuple{StochasticModel,AbstractSampledSolver}","page":"Solver interface","title":"StochasticPrograms.SampledModel","text":"SampledModel(stochasticmodel::StochasticModel, sampler::AbstractSampler, solver::AbstractSampledSolver)\n\nReturn an instance of AbstractSampledModel based on stochasticmodel, sampler and the given solver.\n\nSee also: optimize_sampled!, stochastic_solution\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.StructuredModel-Tuple{StochasticProgram,AbstractStructuredSolver}","page":"Solver interface","title":"StochasticPrograms.StructuredModel","text":"StructuredModel(stochasticprogram::StochasticProgram, solver::AbstractStructuredSolver)\n\nReturn an instance of AbstractStructuredModel based on stochasticprogram and the given solver.\n\nSee also: optimize_structured!, fill_solution!\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.fill_solution!-Tuple{StochasticProgram,AbstractStructuredModel}","page":"Solver interface","title":"StochasticPrograms.fill_solution!","text":"fill_solution!(stochasticprogram::StochasticProgram, structuredmodel::AbstractStructuredModel)\n\nFill in the optimal solution in stochasticprogram after a call to optimize_structured!. Should fill in the first stage result and second stage results for each available scenario.\n\nSee also: optimize_structured!\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.internal_solver-Tuple{AbstractSampledSolver}","page":"Solver interface","title":"StochasticPrograms.internal_solver","text":"internal_solver(solver::AbstractSampledSolver)\n\nReturn an AbstractMathProgSolver, if available, from solver.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.internal_solver-Tuple{AbstractStructuredSolver}","page":"Solver interface","title":"StochasticPrograms.internal_solver","text":"internal_solver(solver::AbstractStructuredSolver)\n\nReturn an AbstractMathProgSolver, if available, from solver.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.optimize_sampled!-Tuple{AbstractSampledModel,AbstractSampler,AbstractFloat}","page":"Solver interface","title":"StochasticPrograms.optimize_sampled!","text":"optimize_sampled!(sampledmodel::AbstractSampledmodel, sampler::AbstractSampler, confidence::AbstractFloat)\n\nOptimize the AbstractSampledModel to the given confidence level, using sampler to generate scenarios. This should approximately optimize the stochasticmodel the sampled model was instantiated from.\n\nSee also: stochastic_solution\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.optimize_structured!-Tuple{AbstractStructuredModel}","page":"Solver interface","title":"StochasticPrograms.optimize_structured!","text":"optimize_structured!(structuredmodel::AbstractStructuredModel)\n\nOptimize the AbstractStructuredModel, which also optimizes the stochasticprogram it was instantiated from.\n\nSee also: fill_solution!\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.solverstr-Tuple{AbstractSampledSolver}","page":"Solver interface","title":"StochasticPrograms.solverstr","text":"solverstr(solver::AbstractStructuredSolver)\n\nOptionally, return a string identifier of AbstractStructuredSolver.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.solverstr-Tuple{AbstractStructuredSolver}","page":"Solver interface","title":"StochasticPrograms.solverstr","text":"solverstr(solver::AbstractStructuredSolver)\n\nOptionally, return a string identifier of AbstractStructuredSolver.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.stochastic_solution-Tuple{AbstractSampledModel}","page":"Solver interface","title":"StochasticPrograms.stochastic_solution","text":"stochastic_solution(sampledmodel::AbstractSampledmodel)\n\nGenerate a StochasticSolution from sampledmodel after a call to optimize_sampled!. The solution should include an approximately optimal first-stage decision, an an approximate optimal value and a confidence interval around the true optimum of the original stochastic model.\n\nSee also: optimize_sampled!, StochasticSolution\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#Execution","page":"Solver interface","title":"Execution","text":"","category":"section"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"Serial\nSynchronous\nAsynchronous","category":"page"},{"location":"library/solverinterface/#StochasticPrograms.Serial","page":"Solver interface","title":"StochasticPrograms.Serial","text":"Serial\n\nFactory object for LShapedSolvers.SerialExecution/ProgressiveHedgingSolvers.SerialExecution. Passed by default to execution in the LShapedSolver and ProgressiveHedgingSolver factory functions.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.Synchronous","page":"Solver interface","title":"StochasticPrograms.Synchronous","text":"Synchronous\n\nFactory object for LShapedSolvers.SynchronousExecution/ProgressiveHedgingSolvers.SynchronousExecution. Pass to execution in the LShapedSolver and ProgressiveHedgingSolver factory functions.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.Asynchronous","page":"Solver interface","title":"StochasticPrograms.Asynchronous","text":"Asynchronous\n\nFactory object for LShapedSolvers.AsynchronousExecution/ProgressiveHedgingSolvers.AsynchronousExecution. Pass to execution in the LShapedSolver and ProgressiveHedgingSolver factory functions\n\n...\n\nParameters\n\nmax_active::Int = 3: Maximum number of active iterations that run asynchronously.\nκ::T = 0.5: Relative amount of finished subproblems required to start a new iterate. Governs the amount of asynchronicity.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#Penalty-terms","page":"Solver interface","title":"Penalty terms","text":"","category":"section"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"Quadratic\nLinearized\nInfNorm\nManhattanNorm","category":"page"},{"location":"library/solverinterface/#StochasticPrograms.Quadratic","page":"Solver interface","title":"StochasticPrograms.Quadratic","text":"Quadratic\n\nFunctor object for using a quadratic 2-norm penalty term. Requires an AbstractMathProgSolver capable of solving QP problems. Passed by default through penalty where applicable.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.Linearized","page":"Solver interface","title":"StochasticPrograms.Linearized","text":"Linearized\n\nFunctor object for using an approximately quadratic penalty term, through linearization. Pass through penalty where applicable.\n\n...\n\nParameters\n\nnbreakpoints::Int: Number of cutting planes used to approximate quadratic term\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.InfNorm","page":"Solver interface","title":"StochasticPrograms.InfNorm","text":"InfNorm\n\nFunctor object for using a linear ∞-norm penalty term. Pass through penalty where applicable.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.ManhattanNorm","page":"Solver interface","title":"StochasticPrograms.ManhattanNorm","text":"ManhattanNorm\n\nFunctor object for using a linear 1-norm penalty term. Pass through penalty where applicable.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#L-shaped-solvers","page":"L-shaped solvers","title":"L-shaped solvers","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Documentation for StochasticPrograms.jl's L-shaped solvers.","category":"page"},{"location":"library/lshaped/#Index","page":"L-shaped solvers","title":"Index","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Pages = [\"lshaped.md\"]","category":"page"},{"location":"library/lshaped/#L-shaped-solver-factory","page":"L-shaped solvers","title":"L-shaped solver factory","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"LShapedSolver\nLShaped","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.LShapedSolver","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.LShapedSolver","text":"LShapedSolver(lpsolver::AbstractMathProgSolver; <keyword arguments>)\n\nReturn an L-shaped algorithm object that can optimize a two-stage StochasticPrograms. Supply lpsolver, a MathProgBase solver capable of solving linear-quadratic problems.\n\nThe following L-shaped regularizations are available\n\nNoRegularization:  L-shaped algorithm (default)\nRegularizedDecomposition:  Regularized decomposition ?RegularizedDecomposition for parameter descriptions.\nTrustRegion:  Trust-region ?TrustRegion for parameter descriptions.\nLevelSet:  Level-set ?LevelSet for parameter descriptions.\n\nThe following aggregation schemes are available\n\nNoAggregation:  Multi-cut L-shaped algorithm (default)\nPartialAggregation:  ?PartialAggregation for parameter descriptions.\nFullAggregation:  ?FullAggregation for parameter descriptions.\nDynamicAggregation:  ?DynamicAggregation for parameter descriptions.\nClusterAggregation:  ?ClusterAggregation for parameter descriptions.\nHybridAggregation:  ?HybridAggregation for parameter descriptions.\n\nThe following consolidation schemes are available\n\nNoConsolidation\nConsolidation\n\nThe following execution policies are available\n\nSerial:  Classical L-shaped (default)\nSynchronous: Classical L-shaped run in parallel\nAsynchronous: Asynchronous L-shaped ?Asynchronous for parameter descriptions.\n\n...\n\nArguments\n\nlpsolver::AbstractMathProgSolver: MathProgBase solver capable of solving linear (and possibly quadratic) programs.\nfeasibility_cuts::Bool = false: Specify if feasibility cuts should be used\nsubsolver::AbstractMathProgSolver = lpsolver: Optionally specify a different solver for the subproblems.\nregularize::AbstractRegularizer = DontRegularize(): Specify regularization procedure (DontRegularize, RegularizedDecomposition/RD/WithRegularizedDecomposition, TrustRegion/TR/WithTrustRegion, LevelSet/LV/WithLevelSets).\naggregate::AbstractAggregator = DontAggregate(): Specify aggregation procedure (DontAggregate, Aggregate, PartialAggregate, DynamicAggregate)\nconsolidate::AbstractConsolidator = DontConsolidate(): Specify consolidation procedure (DontConsolidate, Consolidate)\nexecution::Execution = Serial: Specify how algorithm should be executed (Serial, Synchronous, Asynchronous). Distributed variants requires worker cores.\ncrash::CrashMethod = Crash.None: Crash method used to generate an initial decision. See ?Crash for alternatives.\n<keyword arguments>: Algorithm specific parameters, See ?LShaped for list of possible arguments and default values.\n\n...\n\nExamples\n\nThe following solves a stochastic program sp created in StochasticPrograms.jl using the L-shaped algorithm with GLPK as an lpsolver.\n\njulia> optimize!(sp, solver = LShapedSolver(GLPKSolverLP()))\nL-Shaped Gap  Time: 0:00:00 (6 iterations)\n  Objective:       -855.8333333333339\n  Gap:             0.0\n  Number of cuts:  8\n  Iterations:      6\n:Optimal\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.LShaped","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.LShaped","text":"LShaped\n\nFunctor object for the L-shaped algorithm. Create using the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nAlgorithm parameters\n\nτ::AbstractFloat = 1e-6: Relative tolerance for convergence checks.\ndebug::Bool = false: Specifies if extra information should be saved for debugging purposes. Defaults to false for memory efficiency.\ncut_scaling::AbstractFloat = 1.0: Rescaling factor for cutting planes to improve numerical stability.\nlog::Bool = true: Specifices if L-shaped procedure should be logged on standard output or not.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Execution","page":"L-shaped solvers","title":"Execution","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"LShapedSolvers.SerialExecution\nLShapedSolvers.SynchronousExecution\nLShapedSolvers.AsynchronousExecution","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.SerialExecution","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.SerialExecution","text":"SerialExecution\n\nFunctor object for using serial execution in a lshaped algorithm. Create by supplying a Serial object through execution in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.SynchronousExecution","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.SynchronousExecution","text":"SynchronousExecution\n\nFunctor object for using synchronous execution in an L-shaped algorithm (assuming multiple Julia cores are available). Create by supplying a Synchronous object through execution in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.AsynchronousExecution","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.AsynchronousExecution","text":"AsynchronousExecution\n\nFunctor object for using synchronous execution in an L-shaped algorithm (assuming multiple Julia cores are available). Create by supplying a Asynchronous object through execution in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Regularization","page":"L-shaped solvers","title":"Regularization","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"LShapedSolvers.NoRegularization\nLShapedSolvers.DontRegularize\nLShapedSolvers.RegularizedDecomposition\nLShapedSolvers.RD\nLShapedSolvers.TrustRegion\nLShapedSolvers.TR\nLShapedSolvers.LevelSet\nLShapedSolvers.LV","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.NoRegularization","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.NoRegularization","text":"NoRegularization\n\nEmpty functor object for running an L-shaped algorithm without regularization.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.DontRegularize","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.DontRegularize","text":"DontRegularize\n\nFactory object for NoRegularization. Passed by default to regularize in the LShapedSolver factory function.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.RegularizedDecomposition","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.RegularizedDecomposition","text":"RegularizedDecomposition\n\nFunctor object for using regularized decomposition regularization in an L-shaped algorithm. Create by supplying an RD object through regularize in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nParameters\n\nσ::AbstractFloat = 1.0: Initial value of regularization parameter. Controls the relative penalty of the deviation from the current major iterate.\nσ̅::AbstractFloat = 4.0: Maximum value of the regularization parameter.\nσ̲::AbstractFloat = 0.5: Minimum value of the regularization parameter.\nlog::Bool = true: Specifices if L-shaped procedure should be logged on standard output or not.\npenaltyterm::PenaltyTerm = Quadratic: Specify penaltyterm variant (Quadratic, Linearized, InfNorm, [ManhattanNorm][@ref])\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.RD","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.RD","text":"RD\n\nFactory object for RegularizedDecomposition. Pass to regularize in the LShapedSolver factory function. Equivalent factory calls: RD, WithRD, RegularizedDecomposition, WithRegularizedDecomposition. See ?RegularizedDecomposition for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.TrustRegion","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.TrustRegion","text":"TrustRegion\n\nFunctor object for using trust-region regularization in an L-shaped algorithm. Create by supplying a TR object through regularize in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nParameters\n\nγ::T = 1e-4: Relative tolerance for deciding if a minor iterate should be accepted as a new major iterate.\nΔ::AbstractFloat = 1.0: Initial size of ∞-norm trust-region.\nΔ̅::AbstractFloat = 1000.0: Maximum size of ∞-norm trust-region.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.TR","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.TR","text":"TR\n\nFactory object for TrustRegion. Pass to regularize in the LShapedSolver factory function. Equivalent factory calls: TR, WithTR, TrustRegion, WithTrustRegion. See ?TrustRegion for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.LevelSet","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.LevelSet","text":"LevelSet\n\nFunctor object for using level-set regularization in an L-shaped algorithm. Create by supplying an LV object through regularize in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nParameters\n\nλ::AbstractFloat = 0.5: Controls the level position L = (1-λ)θ + λQ̃, a convex combination of the current lower and upper bound.\npenaltyterm::PenaltyTerm = Quadratic: Specify penaltyterm variant (Quadratic, Linearized, InfNorm, [ManhattanNorm][@ref])\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.LV","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.LV","text":"LV\n\nFactory object for LevelSet. Pass to regularize in the LShapedSolver factory function. Equivalent factory calls: LV, WithLV, LevelSet, WithLevelSets. See ?LevelSet for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Aggregation","page":"L-shaped solvers","title":"Aggregation","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Modules = [LShapedSolvers]\nPages   = [\"no_aggregation.jl\", \"partial_aggregation.jl\", \"dynamic_aggregation.jl\", \"cluster_aggregation.jl\", \"hybrid_aggregation.jl\"]","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.DontAggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.DontAggregate","text":"DontAggregate\n\nFactory object for NoAggregation. Passed by default to aggregate in the LShapedSolver factory function.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.NoAggregation","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.NoAggregation","text":"NoAggregation\n\nEmpty functor object for running an L-shaped algorithm without aggregation (multi-cut L-shaped).\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.Aggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.Aggregate","text":"Aggregate\n\nFactory object for FullAggregation. Pass to aggregate in the LShapedSolver factory function.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.PartialAggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.PartialAggregate","text":"PartialAggregate\n\nFactory object for PartialAggregation. Pass to aggregate in the LShapedSolver factory function.  See ?PartialAggregation for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.PartialAggregation","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.PartialAggregation","text":"PartialAggregation\n\nFunctor object for using partial aggregation in an L-shaped algorithm. Create by supplying a PartialAggregate object through aggregate in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nParameters\n\nsize::Int: Number of cuts in each aggregate\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.FullAggregation-Union{Tuple{T}, Tuple{Integer,Integer,Type{T}}} where T<:AbstractFloat","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.FullAggregation","text":"FullAggregation\n\nFunctor object for using complete aggregation in an L-shaped algorithm. Create by supplying an Aggregate object through aggregate in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.DynamicAggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.DynamicAggregate","text":"DynamicAggregate(naggregates::Integer, rule::SelectionRule; lock_after::Function = (τ,n)->false)\n\nFactory object for DynamicAggregation. Pass to aggregate in the LShapedSolver factory function. See ?DynamicAggregation for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.DynamicAggregation","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.DynamicAggregation","text":"DynamicAggregation\n\nFunctor object for using dynamic aggregation in an L-shaped algorithm. Create by supplying a DynamicAggregate object through aggregate in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\nThe following selection rules are available\n\nSelectUniform\nSelectDecaying\n[SelectRandom](@ref\nSelectClosest\nSelectClosestToReference\n\n...\n\nParameters\n\nnaggregates::Int: Number of aggregates\nrule::SelectionRule: Rule that determines which aggregate an incoming cut should be placed in\nlock_after::Function = (τ,n)->false: Function that determines if the current aggregation scheme should be fixed, based on the current optimality gap τ and the number of iterations n\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.ClusterAggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.ClusterAggregate","text":"ClusterAggregate(rule::ClusterRule; lock_after::Function = (τ,n)->false)\n\nFactory object for ClusterAggregation. Pass to aggregate in the LShapedSolver factory function. See ?ClusterAggregation for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.ClusterAggregation","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.ClusterAggregation","text":"ClusterAggregation\n\nFunctor object for using cluster aggregation in an L-shaped algorithm. Create by supplying a ClusterAggregate object through aggregate in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\nThe following cluster rules are available\n\nStaticCluster\nClusterByReference\n[Kmedoids](@ref\nHierarchical\n\n...\n\nParameters\n\nrule::ClusterRule: Rule that determines how cuts should be sorted into clusters\nlock_after::Function = (τ,n)->false: Function that determines if the current aggregation scheme should be fixed, based on the current optimality gap τ and the number of iterations n\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.HybridAggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.HybridAggregate","text":"HybridAggregate(initial::AbstractAggregator, final::AbstractAggregator, τ::AbstractFloat)\n\nFactory object for HybridAggregation. Pass to aggregate in the LShapedSolver factory function. See ?HybridAggregation for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.HybridAggregation","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.HybridAggregation","text":"HybridAggregation\n\nFunctor object for using hybrid aggregation in an L-shaped algorithm. Create by supplying a HybridAggregate object through aggregate in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nParameters\n\ninitial::AbstractAggregator: Initial aggregation scheme\nfinal::AbstractAggregator: Final aggregation scheme\nτ::T: The active aggregation scheme is switched from initial to final when the optimality gap decreases below τ\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Selection-rules","page":"L-shaped solvers","title":"Selection rules","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Modules = [LShapedSolvers]\nPages   = [\"selection_rules.jl\"]","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.SelectClosest","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.SelectClosest","text":"SelectClosest(τ::AbstractFloat; distance::Function = absolute_distance)\n\nIncoming cuts are placed into the closest aggregate, according the supplied distance function. An empty aggregate is chosen if no aggregate is within the tolerance τ\n\nThe following distance measures are available\n\nabsolute_distance\nangular_distance\n[spatioangular_distance](@ref\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.SelectClosestToReference","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.SelectClosestToReference","text":"SelectClosestToReference(τ::AbstractFloat; distance::Function = absolute_distance)\n\nIncoming cuts are placed into an aggregate based on the distance to a reference cut, according the supplied distance function. Behaves as SelectClosest if not withing the tolerance τ to the reference cut.\n\nThe following distance measures are available\n\nabsolute_distance\nangular_distance\n[spatioangular_distance](@ref\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.SelectDecaying","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.SelectDecaying","text":"SelectDecaying(T₀::Integer, T̲::Integer = 1, γ::T)\n\nBehaves like SelectUniform, but the uniform aggregate size decays by γ each iteration, starting from T₀. T̲ is an optional lower bound on the aggregate size.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.SelectRandom","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.SelectRandom","text":"SelectRandom(max = Inf)\n\nIncoming cuts are placed into aggregates randomly. An optional maximum number of cuts max can be specified.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.SelectUniform","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.SelectUniform","text":"SelectUniform(n::Integer)\n\nIncoming cuts are placed into aggregates uniformly, so that each aggregate has at most n cuts. Behaves as PartialAggregation.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Cluster-rules","page":"L-shaped solvers","title":"Cluster rules","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Modules = [LShapedSolvers]\nPages   = [\"cluster_rules.jl\"]","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.ClusterByReference-Tuple{AbstractFloat}","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.ClusterByReference","text":"ClusterByReference(τ::AbstractFloat; distance::Function = absolute_distance)\n\nBuffered cuts are aggregated if within the tolerance τ to a reference cut, according the supplied distance function. Behaves as multi-cut otherwise.\n\nThe following distance measures are available\n\nabsolute_distance\nangular_distance\n[spatioangular_distance](@ref\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.Hierarchical","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.Hierarchical","text":"Hierarchical(nclusters::Int; distance::Function = absolute_distance, linkage::Symbol = :single)\n\nBuffered cuts are sorted into nclusters clusters, using a Hierarchical algorithm, with the given linkage, over a generalized distance matrix.\n\nThe following distance measures are available\n\nabsolute_distance\nangular_distance\n[spatioangular_distance](@ref\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.Kmedoids","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.Kmedoids","text":"Kmedoids(nclusters::Int; distance::Function = absolute_distance)\n\nBuffered cuts are sorted into nclusters clusters, using a K-medoids algorithm over a generalized distance matrix.\n\nThe following distance measures are available\n\nabsolute_distance\nangular_distance\n[spatioangular_distance](@ref\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.StaticCluster","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.StaticCluster","text":"StaticCluster(clusters::Vector{Float64})\n\nBuffered cuts are sorting according to the supplied weights clusters\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Distance-measures","page":"L-shaped solvers","title":"Distance measures","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Modules = [LShapedSolvers]\nPages   = [\"distance_measures.jl\"]","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.absolute_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.absolute_distance","text":"absolute_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)\n\nAbsolute distance between two optimality cuts\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.angular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.angular_distance","text":"angular_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)\n\nAngular distance between two optimality cuts\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.spatioangular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.spatioangular_distance","text":"spatioangular_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)\n\nSpatioangular distance between two optimality cuts.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#Consolidation","page":"L-shaped solvers","title":"Consolidation","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Modules = [LShapedSolvers]\nPages   = [\"consolidation.jl\"]","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.Consolidate","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.Consolidate","text":"Consolidate\n\nFactory object for Consolidation. Pass to consolidate in the LShapedSolver factory function. See ?Consolidation for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.Consolidation","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.Consolidation","text":"Consolidation\n\nFunctor object for using consolidation in an L-shaped algorithm. Create by supplying a Consolidate object through consolidate in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nAlgorithm parameters\n\ntresh::T = 0.95: Relative amount of redundant cuts in a former iteration required to consider the iteration redundant\nat::Int = 5.0: Number of times an iteration can be redundant before consolidation is triggered\nrebuild::Function = at_tolerance(): Function deciding when the master model should be rebuilt according to performed consolidations\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.DontConsolidate","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.DontConsolidate","text":"DontConsolidate\n\nFactory object for NoConsolidation. Passed by default to consolidate in the LShapedSolver factory function.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.NoConsolidation","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.NoConsolidation","text":"NoRegularization\n\nEmpty functor object for running the L-shaped algorithm without consolidation.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShapedSolvers.at_tolerance-Tuple{}","page":"L-shaped solvers","title":"StochasticPrograms.LShapedSolvers.at_tolerance","text":"at_tolerance(τ = 0.4, miniter = 0)\n\nRebuild master when at least nconsolidations*miniter iterations has passed and the ratio of number of cuts in the consolidated collection and the number of cuts in the master model has decreased below τ.\n\n\n\n\n\n","category":"method"},{"location":"manual/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"manual/examples/#Farmer-problem","page":"Examples","title":"Farmer problem","text":"","category":"section"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"The following defines the well-known \"Farmer problem\", first outlined in Introduction to Stochastic Programming, in StochasticPrograms. The problem revolves around a farmer who needs to decide how to partition his land to sow three different crops. The uncertainty comes from not knowing what the future yield of each crop will be. Recourse decisions involve purchasing/selling crops at the market.","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"using StochasticPrograms\nusing GLPKMathProgInterface","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"We begin by introducing some variable indices:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Crops = [:wheat, :corn, :beets];\nPurchased = [:wheat, :corn];\nSold = [:wheat, :corn, :beets_quota, :beets_extra];","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"The price of beets drops after a certain quantity (6000), so we introduce an extra variable to handle the excess beets. Using the variable indices, we define the deterministic problem parameters:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Cost = Dict(:wheat=>150, :corn=>230, :beets=>260);\nRequired = Dict(:wheat=>200, :corn=>240, :beets=>0);\nPurchasePrice = Dict(:wheat=>238, :corn=>210);\nSellPrice = Dict(:wheat=>170, :corn=>150, :beets_quota=>36, :beets_extra=>10);\nBudget = 500;","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"In the first stage, the farmer needs to know what crops to plant, the cost of planting them, and the available land. Therefore, we introduce the first stage data:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"first_stage_data = (Crops, Cost, Budget)","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"In the second stage, the farmer needs to know the required quantity of each crop, the purchase price, and the sell price:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"second_stage_data = (Required, PurchasePrice, SellPrice)","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"The uncertainty lies in the future yield of each crop. We define a scenario type to capture this:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"@scenario Yield = begin\n    wheat::Float64\n    corn::Float64\n    beets::Float64\nend","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"All of the above definitions can be included directly in the definition of the stochastic model of the farmer problem. Consider","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"farmer_model = @stochastic_model begin\n    @stage 1 begin\n        @parameters begin\n            Crops = [:wheat, :corn, :beets]\n            Cost = Dict(:wheat=>150, :corn=>230, :beets=>260)\n            Budget = 500\n        end\n        @variable(model, x[c = Crops] >= 0)\n        @objective(model, Min, sum(Cost[c]*x[c] for c in Crops))\n        @constraint(model, sum(x[c] for c in Crops) <= Budget)\n    end\n    @stage 2 begin\n        @decision x\n        @parameters begin\n            Purchased  = [:wheat, :corn]\n            Sold = [:wheat, :corn, :bquota, :bextra]\n            Required = Dict(:wheat=>200, :corn=>240, :beets=>0)\n            PurchasePrice = Dict(:wheat=>238, :corn=>210)\n            SellPrice = Dict(:wheat=>170, :corn=>150, :bquota=>36, :bextra=>10)\n        end\n        @uncertain ξ::YieldScenario = begin\n            wheat::Float64\n            corn::Float64\n            beets::Float64\n        end\n        @variable(model, y[p = Purchased] >= 0)\n        @variable(model, w[s = Sold] >= 0)\n        @objective(model, Min, sum( PurchasePrice[p] * y[p] for p = Purchased) - sum( SellPrice[s] * w[s] for s in Sold))\n\n        @constraint(model, const_minreq[p=Purchased],\n            ξ[p] * x[p] + y[p] - w[p] >= Required[p])\n        @constraint(model, const_minreq_beets,\n            ξ[:beets] * x[:beets] - w[:bquota] - w[:bextra] >= Required[:beets])\n        @constraint(model, const_aux, w[:bquota] <= 6000)\n    end\nend","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"The three predicted outcomes can be defined through:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"ξ₁ = YieldScenario(3.0, 3.6, 24.0, probability = 1/3)\nξ₂ = YieldScenario(2.5, 3.0, 20.0, probability = 1/3)\nξ₃ = YieldScenario(2.0, 2.4, 16.0, probability = 1/3)","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"We can now instantiate the farmer problem using the defined stochastic model and the three yield scenarios:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"farmer = instantiate(farmer_model, [ξ₁,ξ₂,ξ₃])","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Printing:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"print(farmer)","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"We can now optimize the model:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"optimize!(farmer, solver = GLPKSolverLP())\nx = optimal_decision(farmer, :x)\nprintln(\"Wheat: $(x[:wheat])\")\nprintln(\"Corn: $(x[:corn])\")\nprintln(\"Beets: $(x[:beets])\")\nprintln(\"Profit: $(optimal_value(farmer))\")","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Finally, we calculate the stochastic performance of the model:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"println(\"EVPI: $(EVPI(farmer, solver = GLPKSolverLP()))\")\nprintln(\"VSS: $(VSS(farmer, solver = GLPKSolverLP()))\")","category":"page"},{"location":"manual/examples/#Continuous-scenario-distribution","page":"Examples","title":"Continuous scenario distribution","text":"","category":"section"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"As an example, consider the following generalized stochastic program:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"DeclareMathOperator*minimizeminimize\nbeginaligned\n minimize_x in mathbbR  quad operatornamemathbbE_omega left(x - xi(omega))^2right \nendaligned","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"where xi(omega) is exponentially distributed. We will skip the mathematical details here and just take for granted that the optimizer to the above problem is the mean of the exponential distribution. We will try to approximately solve this problem using sample average approximation. First, lets try to introduce a custom discrete scenario type that models a stochastic variable with a continuous probability distribution. Consider the following implementation:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"using StochasticPrograms\nusing Distributions\n\nstruct DistributionScenario{D <: UnivariateDistribution} <: AbstractScenario\n    probability::Probability\n    distribution::D\n    ξ::Float64\n\n    function DistributionScenario(distribution::UnivariateDistribution, val::AbstractFloat)\n        return new{typeof(distribution)}(Probability(pdf(distribution, val)), distribution, Float64(val))\n    end\nend\n\nfunction StochasticPrograms.expected(scenarios::Vector{<:DistributionScenario{D}}) where D <: UnivariateDistribution\n    isempty(scenarios) && return DistributionScenario(D(), 0.0)\n    distribution = scenarios[1].distribution\n    return ExpectedScenario(DistributionScenario(distribution, mean(distribution)))\nend","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"The fallback probability method is viable as long as the scenario type contains a Probability field named probability. The implementation of expected is somewhat unconventional as it returns the mean of the distribution regardless of how many scenarios are given.","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"We can implement a sampler that generates exponentially distributed scenarios as follows:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"struct ExponentialSampler <: AbstractSampler{DistributionScenario{Exponential{Float64}}}\n    distribution::Exponential\n\n    ExponentialSampler(θ::AbstractFloat) = new(Exponential(θ))\nend\n\nfunction (sampler::ExponentialSampler)()\n    ξ = rand(sampler.distribution)\n    return DistributionScenario(sampler.distribution, ξ)\nend","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Now, lets attempt to define the generalized stochastic program using the available modeling tools:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"using Ipopt\n\nsm = @stochastic_model begin\n    @stage 1 begin\n        @variable(model, x)\n    end\n    @stage 2 begin\n        @decision x\n        @uncertain ξ from DistributionScenario\n        @variable(model, y)\n        @constraint(model, y == (x - ξ)^2)\n        @objective(model, Min, y)\n    end\nend","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Two-Stage Stochastic Model\n\nminimize f₀(x) + 𝔼[f(x,ξ)]\n  x∈𝒳\n\nwhere\n\nf(x,ξ) = min  f(y; x, ξ)\n              y ∈ 𝒴 (x, ξ)","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"The mean of the given exponential distribution is 20, which is the optimal solution to the general problem. Now, lets create a finite sampled model of 1000 exponentially distributed numbers:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"sampler = ExponentialSampler(2.) # Create a sampler\n\nsp = sample(sm, sampler, 1000) # Sample 1000 exponentially distributed scenarios and create a sampled model","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Stochastic program with:\n * 1 decision variable\n * 1 recourse variable\n * 1000 scenarios of type DistributionScenario\nSolver is default solver","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"By the law of large numbers, we approach the generalized formulation with increasing sample size. Solving yields:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"optimize!(sp, solver = IpoptSolver(print_level=0))\n\nprintln(\"Optimal decision: $(optimal_decision(sp))\")\nprintln(\"Optimal value: $(optimal_value(sp))\")","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Optimal decision: [2.07583]\nOptimal value: 4.00553678799426","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Now, due to the special implementation of the expected function, it actually holds that the expected value solution solves the generalized problem. Consider:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"println(\"EVP decision: $(EVP_decision(sp, solver = IpoptSolver(print_level=0)))\")\nprintln(\"VSS: $(VSS(sp, solver = IpoptSolver(print_level=0)))\")","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"EVP decision: [2.0]\nVSS: 0.005750340653017716","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Accordingly, the VSS is small.","category":"page"},{"location":"manual/model/#Stochastic-models","page":"Stochastic models","title":"Stochastic models","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The @stochastic_model command is now introduced in more detail. The discussion will as before revolve around the simple example introduced in the Quick start:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"simple_model = @stochastic_model begin\n    @stage 1 begin\n        @variable(model, x₁ >= 40)\n        @variable(model, x₂ >= 20)\n        @objective(model, Min, 100*x₁ + 150*x₂)\n        @constraint(model, x₁ + x₂ <= 120)\n    end\n    @stage 2 begin\n        @decision x₁ x₂\n        @uncertain q₁ q₂ d₁ d₂\n        @variable(model, 0 <= y₁ <= d₁)\n        @variable(model, 0 <= y₂ <= d₂)\n        @objective(model, Min, q₁*y₁ + q₂*y₂)\n        @constraint(model, 6*y₁ + 10*y₂ <= 60*x₁)\n        @constraint(model, 8*y₁ + 5*y₂ <= 80*x₂)\n    end\nend","category":"page"},{"location":"manual/model/#[@stage](@ref)-blocks","page":"Stochastic models","title":"@stage blocks","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The body of a @stochastic_model definition consists of a number of @stage blocks, following the syntax:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@stage N begin\n    ...\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Here, N is the stage number and the body is made up of JuMP syntax as well as @parameters, @decision, and @uncertain blocks. At least two stages must be defined and the stages must be defined in consecutive order starting with the first stage. The number of stage blocks included in the @stochastic_model definition determines the number of stages that a stochastic program instantiated from the resulting stochastic model will have.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"note: Note\nIt is possible to define and instantiate stochastic models with more than two stages. However, most internal tools and solvers only support two-stage models at this point.","category":"page"},{"location":"manual/model/#[@parameters](@ref)-blocks","page":"Stochastic models","title":"@parameters blocks","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The @parameters blocks are used to introduce deterministic parameters to a @stage block. See for example Stage data. The following:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@parameters a b","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"makes the constants a and b available as model parameters. This incurs a promise that those parameters will be injected when instantiating the model, and if no default values are available they must be supplied by the user. In other words, if sm is a stochastic model that includes the above @parameters annotation in one of its @stage blocks, then those parameters must be supplied as keyword arguments when instantiating stochastic programs using this model:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"instantiate(sm, scenarios, a = 1, b = 2)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Alternatively, default values can be specified directly in the @parameters block:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@parameters begin\n    a = 1\n    b = 2\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Values supplied to instantiate are always used, and otherwise the default values are used. The responsibility is on the user to ensure that the supplied parameters support the operations used in the @stage blocks. Parameters can be reused in multiple blocks, but each occurance must be annotated by @parameters in each of the stages.","category":"page"},{"location":"manual/model/#[@decision](@ref)-blocks","page":"Stochastic models","title":"@decision blocks","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The @decision blocks are used to annotate linking variables between stages. The @decision block in the simple example above is given by","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@decision x₁ x₂","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"This states that the second stage of the stochastic model depends on the decisions x₁ and x₂ taken in the previous stage. The only restriction is that any variable annotated by @decision in stage N must have been annotated by @variable in stage N-1.","category":"page"},{"location":"manual/model/#[@uncertain](@ref)-blocks","page":"Stochastic models","title":"@uncertain blocks","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The @uncertain blocks are used to annotate stochastic data in the stochastic model. For flexibility, there are several different ways of doing this. However, an @uncertain annotation is always connected to some AbstractScenario type, as introduced in Scenario data. Note, that a @stage block can only include one @uncertain block. All stochastic information in a given stage must therefore be captured in the @uncertain block of that stage.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The most simple approach is to use the Scenario type, which is based on named tuples. Consider the @uncertain annotation given above:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain q₁ q₂ d₁ d₂","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"This will ensure that Scenarios that are expected to have the fields q₁, q₂, d₁ and d₂ are injected when constructing second-stage models. Each such scenario must be supplied or sampled using a supplied sampler object. It is the responsibility of the user to ensure that each supplied or sampled Scenario has the correct fields. For example, the following yields a Scenario compatible with the above @uncertain line:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Scenario(q₁ = -24.0,\n         q₂ = -28.0,\n         d₁ = 500.0,\n         d₂ = 100.0,\n         probability = 0.4)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"As shown in Stochastic data, it is also possible to introduce other scenario types, either using @scenario or manally as explained in Custom scenarios and demonstrated in the Continuous scenario distribution example. If we instead define the necessary scenario structure as follows:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@scenario SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"One can then use:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain ξ::SimpleScenario","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"and extract the required fields from ξ which will be of type SimpleScenario after data injection. Again, it is the responsibility of the user to supply scenarios of this type when instantiating the model. For example, the following constructs a SimpleScenario compatible with the above @uncertain line:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"SimpleScenario(-24.0, -28.0, 500.0, 100.0, probability = 0.4)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"It is also possible to directly unpack the necessary fields using the following syntactic sugar:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain q₁ q₂ d₁ d₂ from SimpleScenario","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The actual scenario instance can still be annotated and used if necessary:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain q₁ q₂ d₁ d₂ from ξ::SimpleScenario","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Finally, if the @uncertain block is used within a @stochastic_model environment, it is possible to simultaneosly define the underlying scenario type. In other words,","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain ξ::SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain q₁ q₂ d₁ d₂ from SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"and","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain q₁ q₂ d₁ d₂ from ξ::SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"are all possible methods of defining and using the SimpleScenario type in a @stage block.","category":"page"},{"location":"manual/model/#Model-instantiation","page":"Stochastic models","title":"Model instantiation","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"A model object sm defined using @stochastic_model can be used to instantiate stochastic programs over both finite/infinite sample spaces and discrete/continuous random variables.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"If the scenarios are associated with a discrete random variable over a finite sample space, then the corresponding stochastic program is finite and can be instantiated by providing the full list of scenarios:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"sp = instantiate(sm, scenarios)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Here, scenarios is a vector of scenarios consistent with the @uncertain annotation used in the second stage of sm. It is the responsibility of the user to ensure that the individual probabilities of the scenarios sum up to one, so that the model is consistent.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"If the scenarios are instead associated with a continuous random variable, with finite second moments, over an infinite sample space, then the corresponding stochastic program is not finite and must be approximated. The only supported way of doing so in StochasticPrograms is by using sampled average approximations. A finite stochastic program that approximates the stochastic model is obtained through","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"sp = sample(sm, sampler, n)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"where sampler is an AbstractSampler, as outlined in Sampling, and n is the number of samples to include.","category":"page"},{"location":"manual/model/#Instant-models","page":"Stochastic models","title":"Instant models","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"It is possible to create one-off stochastic programs without needing to first define a model object. To do so, any required scenario data structure must be defined first. Consider:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"using StochasticPrograms\n\n@scenario SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend\nξ₁ = SimpleScenario(-24.0, -28.0, 500.0, 100.0, probability = 0.4)\nξ₂ = SimpleScenario(-28.0, -32.0, 300.0, 300.0, probability = 0.6)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Next, an unmodeled stochastic program can be instantiated using the two created scenarios:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"sp = StochasticProgram([ξ₁, ξ₂])","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"A slightly diferrent modeling syntax is now used to define the stage models of sp:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@first_stage sp = begin\n    @variable(model, x₁ >= 40)\n    @variable(model, x₂ >= 20)\n    @objective(model, Min, 100*x₁ + 150*x₂)\n    @constraint(model, x₁ + x₂ <= 120)\nend\n@second_stage sp = begin\n    @decision x₁ x₂\n    @uncertain q₁ q₂ d₁ d₂ from SimpleScenario\n    @variable(model, 0 <= y₁ <= d₁)\n    @variable(model, 0 <= y₂ <= d₂)\n    @objective(model, Min, q₁*y₁ + q₂*y₂)\n    @constraint(model, 6*y₁ + 10*y₂ <= 60*x₁)\n    @constraint(model, 8*y₁ + 5*y₂ <= 80*x₂)\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Here, @first_stage and @second_stage are just syntactic sugar for @stage 1 and @stage 2. This is is the definition syntax used internally by StochasticModel objects when instantiating stochastic programs. We can verify that this approach yields the same stochastic program by printing and comparing to the Quick start:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"print(sp)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"As a side note, it is possible to run stage definition macros on programs with existing models. This overwrites the previous model and reinstantiates all internal problems. For example, the following increases the lower bound on the second stage variables to 2:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@second_stage sp = begin\n    @decision x₁ x₂\n    @uncertain q₁ q₂ d₁ d₂ from SimpleScenario\n    @variable(model, 2 <= y₁ <= d₁)\n    @variable(model, 2 <= y₂ <= d₂)\n    @objective(model, Min, q₁*y₁ + q₂*y₂)\n    @constraint(model, 6*y₁ + 10*y₂ <= 60*x₁)\n    @constraint(model, 8*y₁ + 5*y₂ <= 80*x₂)\nend\n\nprint(sp)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"It is of course also possible to do this on programs instantiated from a StochasticModel.","category":"page"},{"location":"manual/distributed/#Distributed-stochastic-programs","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"","category":"section"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"Stochastic programs related to industrial applications are often associated with complex models and vast numbers of scenarios, often in the order of 1000-1000000. Hence, the extensive form can have billions of variables and constraints, and often does not fit in memory on a single machine. This clarifies the need for solution approaches that work in parallel on distributed data when instansiating and optimizing large-scale stochastic programs.","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"If multiple Julia processes are available, locally or in a cluster, StochasticPrograms natively distributes any defined stochastic programs on the available processing nodes. Consider as before:","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"using Distributed\n\naddprocs(3)\n\n@everywhere using StochasticPrograms\n\n@scenario Simple = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend\n\n@sampler SimpleSampler = begin\n    @sample begin\n        return SimpleScenario(-24.0 + 2*(2*rand()-1),\n                              -28.0 + (2*rand()-1),\n                              300.0 + 100*(2*rand()-1),\n                              300.0 + 100*(2*rand()-1),\n                              probability = rand())\n    end\nend","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"@scenario and @sampler automatically ensures that the introduced scenario and sampler types are available on all processes. Define the stochastic model in the usual way:","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"simple_model = @stochastic_model begin\n    @stage 1 begin\n        @variable(model, x₁ >= 40)\n        @variable(model, x₂ >= 20)\n        @objective(model, Min, 100*x₁ + 150*x₂)\n        @constraint(model, x₁ + x₂ <= 120)\n    end\n    @stage 2 begin\n        @decision x₁ x₂\n        @uncertain q₁ q₂ d₁ d₂ from SimpleScenario\n        @variable(model, 0 <= y₁ <= d₁)\n        @variable(model, 0 <= y₂ <= d₂)\n        @objective(model, Min, q₁*y₁ + q₂*y₂)\n        @constraint(model, 6*y₁ + 10*y₂ <= 60*x₁)\n        @constraint(model, 8*y₁ + 5*y₂ <= 80*x₂)\n    end\nend","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"and instantiate a sampled model with 10 sceanarios:","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"sp = sample(simple_model, SimpleSampler(), 10)","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"the lightweight model recipes are passed to all worker nodes. The worker nodes then use the recipes and lightweight sampler object to instansiate second stage models in parallel. This is one of the intended outcomes of the design choices made in StochasticPrograms. The separation between data design and model design allows us to minimize data passing in a natural way.","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"Many operations in StochasticPrograms are embarassingly parallel which is exploited throughout when a stochastic program is distributed. Notably:","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"evaluate_decision\nEVPI\nVSS","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"Perform many subproblem independent operations in parallel. The best performance is achieved if the optimization of the recourse problem is performed by an algorithm that can operate in parallel on the distributed stochastic programs. The solver suites LShapedSolvers and ProgressiveHedgingSolvers are examples of this. For example, we can optimize the distributed version of the simple stochastic program with a parallelized L-shaped algorithm as follows:","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"using LShapedSolvers\nusing GLPKMathProgInterface\n\noptimize!(sp, solver = LShapedSolver(GLPKSolverLP(), execution = Synchronous()))","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"Distributed L-Shaped Gap  Time: 0:00:03 (6 iterations)\n  Objective:       -855.8333333333339\n  Gap:             0.0\n  Number of cuts:  7\n:Optimal","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"A quick note should also be made about the API calls that become less efficient in a distributed setting. This includes all calls that collect data that reside on remote processes. The functions in this category that involve the most data passing is scenarios, which fetches all scenarios in the stochastic program, and subproblems, which fetches all second stage models in the stochastic program. If these collections are required frequently it is recommended to not distribute the stochastic program. This can be ensured by supplying procs = [1] to the constructor call. Individual queries scenario(stochasticprogram, i) and subproblem(stochasticprogram, i) are viable depending on the size of the scenarios/models. If a MathProgBase solver is supplied to a distributed stochastic program it will fetch all scenarios to the master node and attempt to build the extensive form. Long computation times are expected for large-scale models, assuming they fit in memory. If so, it is again recommended to avoid distributing the stochastic program through procs = [1]. The best approach is to use a structured solver that can operate on distributed stochastic programs, such as LShapedSolvers or ProgressiveHedgingSolvers.","category":"page"},{"location":"library/progressivehedging/#Progressive-hedging-solvers","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"","category":"section"},{"location":"library/progressivehedging/","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"Documentation for StochasticPrograms.jl's progressive-hedging solvers.","category":"page"},{"location":"library/progressivehedging/#Index","page":"Progressive-hedging solvers","title":"Index","text":"","category":"section"},{"location":"library/progressivehedging/","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"Pages = [\"progressivehedging.md\"]","category":"page"},{"location":"library/progressivehedging/#Progressive-hedging-solver-factory","page":"Progressive-hedging solvers","title":"Progressive-hedging solver factory","text":"","category":"section"},{"location":"library/progressivehedging/","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"ProgressiveHedgingSolver\nProgressiveHedging","category":"page"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.ProgressiveHedgingSolver","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedgingSolvers.ProgressiveHedgingSolver","text":"ProgressiveHedgingSolver(qpsolver::AbstractMathProgSolver; <keyword arguments>)\n\nReturn a progressive-hedging algorithm object specified. Supply qpsolver, a MathProgBase solver capable of solving quadratic problems.\n\nThe following penalty parameter update procedures are available\n\nFixed:  Fixed penalty (default) ?Fixed for parameter descriptions.\nAdaptive: Adaptive penalty update ?Adaptive for parameter descriptions.\n\nThe following execution policies are available\n\nSerial:  Classical progressive-hedging (default)\nSynchronous: Classical progressive-hedging run in parallel\nAsynchronous: Asynchronous progressive-hedging ?Asynchronous for parameter descriptions.\n\n...\n\nArguments\n\nqpsolver::AbstractMathProgSolver: MathProgBase solver capable of solving quadratic programs.\npenalty::AbstractPenalizer = Fixed(): Specify penalty update procedure (Fixed, Adaptive)\nexecution::AbstractExecuter = Serial: Specify how algorithm should be executed (Serial, Synchronous, Asynchronous). Distributed variants requires worker cores.\npenaltyterm::PenaltyTerm = Quadratic: Specify penaltyterm variant (Quadratic, Linearized, InfNorm, [ManhattanNorm][@ref])\n<keyword arguments>: Algorithm specific parameters, consult individual docstrings (see above list) for list of possible arguments and default values.\n\n...\n\nExamples\n\nThe following solves a stochastic program sp created in StochasticPrograms.jl using the progressive-hedging algorithm with Ipopt as an qpsolver.\n\njulia> solve(sp,solver=ProgressiveHedgingSolver(IpoptSolver(print_level=0)))\nProgressive Hedging Time: 0:00:06 (1315 iterations)\n  Objective:  -855.8332803469432\n  δ:          9.436947935542464e-7\n:Optimal\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.ProgressiveHedging","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedgingSolvers.ProgressiveHedging","text":"ProgressiveHedging\n\nFunctor object for the progressive-hedging algorithm. Create using the ProgressiveHedgingSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nParameters\n\nτ::AbstractFloat = 1e-6: Relative tolerance for convergence checks.\nlog::Bool = true: Specifices if progressive-hedging procedure should be logged on standard output or not.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#Execution","page":"Progressive-hedging solvers","title":"Execution","text":"","category":"section"},{"location":"library/progressivehedging/","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"ProgressiveHedgingSolvers.SerialExecution\nProgressiveHedgingSolvers.SynchronousExecution\nProgressiveHedgingSolvers.AsynchronousExecution","category":"page"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.SerialExecution","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedgingSolvers.SerialExecution","text":"SerialExecution\n\nFunctor object for using serial execution in a progressive-hedging algorithm. Create by supplying a Serial object through execution in the ProgressiveHedgingSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.SynchronousExecution","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedgingSolvers.SynchronousExecution","text":"SynchronousExecution\n\nFunctor object for using synchronous execution in a progressive-hedging algorithm (assuming multiple Julia cores are available). Create by supplying a Synchronous object through execution in the ProgressiveHedgingSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.AsynchronousExecution","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedgingSolvers.AsynchronousExecution","text":"AsynchronousExecution\n\nFunctor object for using asynchronous execution in a progressive-hedging algorithm (assuming multiple Julia cores are available). Create by supplying an Asynchronous object through execution in the ProgressiveHedgingSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#Penalties","page":"Progressive-hedging solvers","title":"Penalties","text":"","category":"section"},{"location":"library/progressivehedging/","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"ProgressiveHedgingSolvers.FixedPenalization\nProgressiveHedgingSolvers.Fixed\nProgressiveHedgingSolvers.AdaptivePenalization\nProgressiveHedgingSolvers.Adaptive","category":"page"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.FixedPenalization","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedgingSolvers.FixedPenalization","text":"FixedPenalization\n\nFunctor object for using fixed penalty in a progressive-hedging algorithm. Create by supplying a Fixed object through penalty in the ProgressiveHedgingSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nParameters\n\nr::T = 1.00: Fixed penalty\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.Fixed","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedgingSolvers.Fixed","text":"Fixed\n\nFactory object for FixedPenalization. Pass to penalty in the ProgressiveHedgingSolver factory function. See ?FixedPenalization for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.AdaptivePenalization","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedgingSolvers.AdaptivePenalization","text":"AdaptivePenalization\n\nFunctor object for using adaptive penalty in a progressive-hedging algorithm. Create by supplying an Adaptive object through penalty in the ProgressiveHedgingSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nParameters\n\nζ::T = 0.1: Used to calculate the initial penalty. Non-anticipativity in the initial decision is enforced more as ζ increase.\nγ₁::T = 1e-5: Tolerance for primal changes being significant\nγ₂::T = 0.01: Tolerance for primal changes dominating dual changes\nγ₃::T = 0.25: Tolerance for dual changes dominating primal changes\nσ::T = 1e-5: Tolerance for the quadratic penalty dominating the Lagrangian\nα::T = 0.95: Penalty decrease after primal changes dominating dual changes\nθ::T = 1.1: Penalty increase after dual changes dominating primal changes\nν::T = 0.1: Tolerance for significant non-anticipativity violation\nβ::T = 1.1: Penalty increase after increased non-anticipativity violation\nη::T = 1.25: Default penalty increase in the default case\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.Adaptive","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedgingSolvers.Adaptive","text":"Adaptive\n\nFactory object for AdaptivePenalization. Pass to penalty in the ProgressiveHedgingSolver factory function. See ?AdaptivePenalization for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"#StochasticPrograms.jl","page":"Home","title":"StochasticPrograms.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A modeling framework for stochastic programming problems","category":"page"},{"location":"#Summary","page":"Home","title":"Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StochasticPrograms models recourse problems where an initial decision is taken, unknown parameters are observed, followed by recourse decisions to correct any inaccuracy in the initial decision. The underlying optimization problems are formulated in JuMP.jl. In StochasticPrograms, model instantiation can be deferred until required. As a result, scenario data can be loaded/reloaded to create/rebuild the recourse model at a later stage, possibly on separate machines in a cluster. Another consequence of deferred model instantiation is that StochasticPrograms.jl can provide stochastic programming constructs, such as expected value of perfect information (EVPI) and value of the stochastic solution (VSS), to gain deeper insights about formulated recourse problems. A good introduction to recourse models, and to the stochastic programming constructs provided in this package, is given in Introduction to Stochastic Programming. A stochastic program has a structure that can be exploited in solver algorithms. Therefore, StochasticPrograms provides a structured solver interface. Furthermore, a suite of solvers based on L-shaped and progressive-hedging algorithms that implements this interface are included. StochasticPrograms has parallel capabilities, implemented using the standard Julia library for distributed computing.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flexible problem definition\nDeferred model instantiation\nScenario data injection\nNatively distributed\nInterface to structure-exploiting solver algorithms\nEfficient parallel implementations of classical algorithms","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider Quick start for a tutorial explaining how to get started using StochasticPrograms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some examples of models written in StochasticPrograms can be found on the Examples page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use StochasticPrograms, please cite the following preprint:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{spjl,\n  title     = {Efficient Stochastic Programming in {J}ulia},\n  author    = {Martin Biel and Mikael Johansson},\n  journal   = {arXiv preprint arXiv:1909.10451},\n  year      = {2019}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use the cut aggregation funcionality for L-shaped, please cite the following preprint","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{cutaggregation,\n  title     = {Dynamic cut aggregation in {L}-shaped algorithms},\n  author    = {Martin Biel and Mikael Johansson},\n  journal   = {arXiv preprint arXiv:1910.13752},\n  year      = {2019}\n}","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual/quickstart.md\", \"manual/data.md\", \"manual/model.md\", \"manual/distributed.md\", \"manual/structuredsolvers.md\", \"manual/examples.md\"]","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library/public.md\", \"library/solverinterface.md\", \"library/crash.md\", \"library/lshaped.md\", \"library/progressivehedging.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library/public.md\"]\nOrder   = [:type, :macro, :function]","category":"page"},{"location":"library/public/#Public-interface","page":"Public interface","title":"Public interface","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Documentation for StochasticPrograms.jl's public interface.","category":"page"},{"location":"library/public/#Contents","page":"Public interface","title":"Contents","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Pages = [\"public.md\"]","category":"page"},{"location":"library/public/#Index","page":"Public interface","title":"Index","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Pages = [\"public.md\"]\nOrder   = [:type, :macro, :function]","category":"page"},{"location":"library/public/#Constructors","page":"Public interface","title":"Constructors","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Modules = [StochasticPrograms]\nPages   = [\"stochasticprogram.jl\"]","category":"page"},{"location":"library/public/#StochasticPrograms.StochasticProgram-Tuple{Any,Any,Array{#s39,1} where #s39<:AbstractScenario}","page":"Public interface","title":"StochasticPrograms.StochasticProgram","text":"StochasticProgram(first_stage_params::Any,\n                  second_stage_params::Any,\n                  scenarios::Vector{<:AbstractScenario};\n                  solver = JuMP.UnsetSolver(),\n                  procs = workers())\n\nCreate a new two-stage stochastic program with a given collection of scenarios\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.StochasticProgram-Tuple{Array{#s39,1} where #s39<:AbstractScenario}","page":"Public interface","title":"StochasticPrograms.StochasticProgram","text":"StochasticProgram(scenarios::Vector{<:AbstractScenario};\n                  solver = JuMP.UnsetSolver(),\n                  procs = workers()) where {SD <: AbstractScenario}\n\nCreate a new two-stage stochastic program with a given collection of scenarios and no stage data.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.StochasticProgram-Union{Tuple{S}, Tuple{Any,Any,Type{S}}} where S<:AbstractScenario","page":"Public interface","title":"StochasticPrograms.StochasticProgram","text":"StochasticProgram(first_stage_params::Any,\n                  second_stage_params::Any,\n                  ::Type{S};\n                  solver = JuMP.UnsetSolver(),\n                  procs = workers()) where S <: AbstractScenario\n\nCreate a new two-stage stochastic program with stage data given by first_stage_params and second_stage_params. After construction, scenarios of type S can be added through add_scenario!. Optionally, a capable solver can be supplied to later optimize the stochastic program. If multiple Julia processes are available, the resulting stochastic program will automatically be memory-distributed on these processes. This can be avoided by setting procs = [1].\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.StochasticProgram-Union{Tuple{S}, Tuple{Any,Any}} where S<:AbstractScenario","page":"Public interface","title":"StochasticPrograms.StochasticProgram","text":"StochasticProgram(first_stage_params::Any,\n                  second_stage_params::Any,\n                  solver = JuMP.UnsetSolver(),\n                  procs = workers())\n\nCreate a new two-stage stochastic program with stage data given by first_stage_params and second_stage_params. After construction, scenarios of type Scenario can be added through add_scenario!. Optionally, a capable solver can be supplied to later optimize the stochastic program. If multiple Julia processes are available, the resulting stochastic program will automatically be memory-distributed on these processes. This can be avoided by setting procs = [1].\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.StochasticProgram-Union{Tuple{Type{S}}, Tuple{S}} where S<:AbstractScenario","page":"Public interface","title":"StochasticPrograms.StochasticProgram","text":"StochasticProgram(::Type{S};\n                  solver = JuMP.UnsetSolver(),\n                  procs = workers()) where S <: AbstractScenario\n\nCreate a new two-stage stochastic program with scenarios of type S and no stage data.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.StochasticProgram-Union{Tuple{}, Tuple{S}} where S<:AbstractScenario","page":"Public interface","title":"StochasticPrograms.StochasticProgram","text":"StochasticProgram(; solver = JuMP.UnsetSolver(),\n                  procs = workers())\n\nCreate a new two-stage stochastic program with scenarios of type S and no stage data.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Scenarios","page":"Public interface","title":"Scenarios","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Modules = [StochasticPrograms]\nPages   = [\"scenario.jl\"]","category":"page"},{"location":"library/public/#StochasticPrograms.AbstractScenario","page":"Public interface","title":"StochasticPrograms.AbstractScenario","text":"AbstractScenario\n\nAbstract supertype for scenario objects.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.ExpectedScenario","page":"Public interface","title":"StochasticPrograms.ExpectedScenario","text":"ExpectedScenario{S <: AbstractScenario}\n\nWrapper type around an AbstractScenario. Should for convenience be used as the result of a call to expected.\n\nSee also expected\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.Probability","page":"Public interface","title":"StochasticPrograms.Probability","text":"Probability\n\nA type-safe wrapper for Float64 used to represent probability of a scenario occuring.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.Scenario","page":"Public interface","title":"StochasticPrograms.Scenario","text":"Scenario\n\nConveniece type that adheres to the AbstractScenario abstraction. Useful when uncertain parameters are a finite set of scalar values.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.expected-Union{Tuple{Array{S,1}}, Tuple{S}} where S<:AbstractScenario","page":"Public interface","title":"StochasticPrograms.expected","text":"expected(scenarios::Vector{<:AbstractScenario})\n\nReturn the expected scenario out of the collection scenarios in an ExpectedScenario wrapper.\n\nThis is defined through classical expectation: sum([probability(s)*s for s in scenarios]), and is always defined for scenarios created through @scenario, if the requested fields support it.\n\nOtherwise, user-defined scenario types must implement this method for full functionality.\n\nSee also ExpectedScenario\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.probability-Tuple{AbstractScenario}","page":"Public interface","title":"StochasticPrograms.probability","text":"probability(scenario::AbstractScenario)\n\nReturn the probability of scenario occuring.\n\nIs always defined for scenarios created through @scenario. Other user defined scenario types must implement this method to generate a proper probability. The default behaviour is to assume that scenario has a probability field of type Probability\n\nSee also: Probability\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.probability-Tuple{Array{#s13,1} where #s13<:AbstractScenario}","page":"Public interface","title":"StochasticPrograms.probability","text":"probability(scenarios::Vector{<:AbstractScenario})\n\nReturn the probability of that any scenario in the collection scenarios occurs.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.scenariotext-Tuple{IO,AbstractScenario}","page":"Public interface","title":"StochasticPrograms.scenariotext","text":"scenariotext(io::IO, scenario::AbstractScenario)\n\nCustom printout called when printing scenario.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.set_probability!-Tuple{AbstractScenario,AbstractFloat}","page":"Public interface","title":"StochasticPrograms.set_probability!","text":"set_probability!(scenario::AbstractScenario, probability::AbstractFloat)\n\nSet the probability of scenario occuring.\n\nIs always defined for scenarios created through @scenario. Other user defined scenario types must implement this method.\n\n\n\n\n\n","category":"method"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"AbstractSampler\nSampler\nsample","category":"page"},{"location":"library/public/#StochasticPrograms.AbstractSampler","page":"Public interface","title":"StochasticPrograms.AbstractSampler","text":"AbstractSampler\n\nAbstract supertype for sampler objects.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.Sampler","page":"Public interface","title":"StochasticPrograms.Sampler","text":"Sampler\n\nGeneral purpose sampler object that samples Scenario.\n\nSee also: Scenario, @sampler\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.sample","page":"Public interface","title":"StochasticPrograms.sample","text":"sample(sampler::AbstractSampler{S})\n\nSample a scenario of type S using sampler.\n\n\n\n\n\nsample(sampler::AbstractSampler{S}, π::AbstractSampler)\n\nSample a scenario of type S using sampler and set the probability of the sampled scenario to π.\n\n\n\n\n\nsample(stochasticmodel::StochasticModel, sampler::AbstractSampler, n::Integer; solver = JuMP.UnsetSolver())\n\nGenerate a sampled instance of size n using the model stored in the two-stage stochasticmodel, and the provided sampler.\n\nOptionally, a capable solver can be supplied to sample. Otherwise, any previously set solver will be used.\n\nSee also: sample!\n\n\n\n\n\n","category":"function"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"DocTestSetup = quote\n    using StochasticPrograms\nend","category":"page"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"@scenario\n@zero\n@expectation\n@sampler\n@sample","category":"page"},{"location":"library/public/#StochasticPrograms.@scenario","page":"Public interface","title":"StochasticPrograms.@scenario","text":"@scenario(def)\n\nDefine a scenario type compatible with StochasticPrograms using the syntax\n\n@scenario name = begin\n    ...structdef...\n\n    [@zero begin\n        ...\n        return zero(scenario)\n    end]\n\n    [@expectation begin\n        ...\n        return expected(scenarios)\n     end]\nend\n\nThe generated type is referenced through name and a default constructor is always generated. This constructor accepts the keyword probability to set the probability of the scenario occuring. Otherwise, any internal variables and specialized constructors are defined in the @scenario block as they would be in any Julia struct.\n\nIf possible, a zero method and an expected method will be generated for the defined type. Otherwise, or if the default implementation is not desired, these can be user provided through @zero and @expectation.\n\nThe defined scenario type will be available on all Julia processes.\n\nExamples\n\nThe following defines a simple scenario ξ with a single value.\n\n@scenario ExampleScenario = begin\n    ξ::Float64\nend\n\nExampleScenario(1.0, probability = 0.5)\n\n# output\n\nExampleScenario with probability 0.5\n  ξ: 1.0\n\n\nSee also: @zero, @expectation, @sampler\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@zero","page":"Public interface","title":"StochasticPrograms.@zero","text":"@zero(def)\n\nDefine the additive zero scenario inside a @scenario block using the syntax:\n\n@zero begin\n    ...\n    return zero_scenario\nend\n\nExamples\n\nThe following defines a zero scenario for the example scenario defined in @scenario\n\n@zero begin\n    return ExampleScenario(0.0)\nend\n\nSee also @scenario\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@expectation","page":"Public interface","title":"StochasticPrograms.@expectation","text":"@expectation(def)\n\nDefine how to form the expected scenario inside a @scenario block. The scenario collection is accessed through the reserved keyword scenarios.\n\n@zero begin\n    ...\n    return zero_scenario\nend\n\nExamples\n\nThe following defines expectation for the example scenario defined in @scenario\n\n@expectation begin\n    return ExampleScenario(sum([probability(s)*s.ξ for s in scenarios]))\nend\n\nSee also @scenario\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@sampler","page":"Public interface","title":"StochasticPrograms.@sampler","text":"@sampler(def)\n\nDefine a sampler type for some scenariotype compatible with StochasticPrograms using the syntax\n\n@sampler samplername = begin\n    ...internals...\n\n    @sample scenariotype begin\n        ...\n        return scenario\n    end\nend\n\nAny internal state required by the sampler, as well as any specialized constructor, are defined in the @sampler block as they would be in any Julia struct. Define the sample operation inside the @sample block and specify the scenariotype that the sampler returns. The defined sampler will be available on all Julia processes.\n\nExamples\n\nThe following defines a simple dummy sampler, with some internal weight value, for the scenario defined in @scenario, and samples one scenario.\n\n@sampler ExampleSampler = begin\n    w::Float64\n\n    ExampleSampler(w::AbstractFloat) = new(w)\n\n    @sample ExampleScenario begin\n        @parameters w\n        return ExampleScenario(w*randn(), probability = rand())\n    end\nend\ns = ExampleSampler(2.0)\ns()\n\n# output\n\nExampleScenario with probability 0.29\n  ξ: 1.48\n\n\n\nSee also: @sample, @scenario\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@sample","page":"Public interface","title":"StochasticPrograms.@sample","text":"@sample(def)\n\nDefine the sample operaton inside a @sampler block, using the syntax\n\n@sample begin\n    ...\n    return sampled_scenario\nend\n\nThe sampler object is referenced through the reserved keyword sampler, from which any internals can be accessed.\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#Model-definition","page":"Public interface","title":"Model definition","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"@stage\n@first_stage\n@second_stage\n@decision\n@parameters\n@uncertain\n@stochastic_model","category":"page"},{"location":"library/public/#StochasticPrograms.@stage","page":"Public interface","title":"StochasticPrograms.@stage","text":"@stage(def)\n\nAdd a stage model generation recipe to stochasticprogram using the syntax\n\n@stage stage stochasticprogram::StochasticProgram = begin\n    @parameters param1 param2 ...\n    @decision var1 var2 ...\n    @uncertain ξ\n    ... JuMPdef ...\n    ...\nend [defer]\n\nwhere JuMP syntax is used inside the block to define the stage model. During definition, the second stage model is referenced through the reserved keyword model.\n\nOptionally, give the keyword defer after the  to delay generation of the stage model.\n\nExamples\n\nThe following defines the first stage model given by:\n\n  minimize 100x₁ + 150x₂\n    st  x₁ + x₂  120\n         x₁  40\n         x₂  20\n\nand the second-stage model given by:\n\n  minimize q₁(ξ)y₁ + q₂(ξ)y₂\n    st  6y₁ + 10y₂  60x₁\n         8y₁ + 5y₂  60x₂\n         0  y₁  d₁(ξ)\n         0  y₂  d₂(ξ)\n\nwhere q₁(ξ) q₂(ξ) d₁(ξ) d₂(ξ) depend on the scenario ξ and x₁ x₂ are first stage variables. Two scenarios are added so that two second stage models are generated.\n\nξ₁ = Scenario(q₁ = -24.0, q₂ = -28.0, d₁ = 500.0, d₂ = 100.0, probability = 0.4)\nξ₂ = Scenario(q₁ = -28.0, q₂ = -32.0, d₁ = 300.0, d₂ = 300.0, probability = 0.6)\n\nsp = StochasticProgram([ξ₁, ξ₂])\n\n@stage 1 sp = begin\n    @variable(model, x₁ >= 40)\n    @variable(model, x₂ >= 20)\n    @objective(model, Min, 100*x₁ + 150*x₂)\n    @constraint(model, x₁ + x₂ <= 120)\nend\n\n@stage 2 sp = begin\n    @decision x₁ x₂\n    @uncertain q₁ q₂ d₁ d₂\n    @variable(model, 0 <= y₁ <= d₁)\n    @variable(model, 0 <= y₂ <= d₂)\n    @objective(model, Min, q₁*y₁ + q₂*y₂)\n    @constraint(model, 6*y₁ + 10*y₂ <= 60*x₁)\n    @constraint(model, 8*y₁ + 5*y₂ <= 80*x₂)\nend\n\n# output\n\nStochastic program with:\n * 2 decision variables\n * 2 recourse variables\n * 2 scenarios of type Scenario\nSolver is default solver\n\n\nSee also: @parameters, @decision, @uncertain\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@first_stage","page":"Public interface","title":"StochasticPrograms.@first_stage","text":"@first_stage(def)\n\nAdd a first stage model generation recipe to stochasticprogram using the syntax\n\n@first_stage stochasticprogram::StochasticProgram = begin\n    ...\nend [defer]\n\nwhere JuMP syntax is used inside the block to define the first stage model. During definition, the first stage model is referenced through the reserved keyword model.\n\nOptionally, give the keyword defer after the  to delay generation of the first stage model.\n\nExamples\n\nThe following defines the first stage model given by:\n\n  minimize 100x₁ + 150x₂\n    st  x₁ + x₂  120\n         x₁  40\n         x₂  20\n\n@first_stage sp = begin\n    @variable(model, x₁ >= 40)\n    @variable(model, x₂ >= 20)\n    @objective(model, Min, 100*x₁ + 150*x₂)\n    @constraint(model, x₁ + x₂ <= 120)\nend\n\nSee also: @second_stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@second_stage","page":"Public interface","title":"StochasticPrograms.@second_stage","text":"@second_stage(def)\n\nAdd a second stage model generation recipe to stochasticprogram using the syntax\n\n@second_stage stochasticprogram::StochasticProgram = begin\n    @decision var1 var2 ...\n    ...\nend [defer]\n\nwhere JuMP syntax is used inside the block to define the second stage model. During definition, the second stage model is referenced through the reserved keyword model.\n\nOptionally, give the keyword defer after the  to delay generation of the first stage model.\n\nExamples\n\nThe following defines the second stage model given by:\n\n  minimize q₁(ξ)y₁ + q₂(ξ)y₂\n    st  6y₁ + 10y₂  60x₁\n         8y₁ + 5y₂  60x₂\n         0  y₁  d₁(ξ)\n         0  y₂  d₂(ξ)\n\nwhere q₁(ξ) q₂(ξ) d₁(ξ) d₂(ξ) depend on the scenario ξ and x₁ x₂ are first stage variables. Two scenarios are added so that two second stage models are generated.\n\n@second_stage sp = begin\n    @decision x₁ x₂\n    @uncertain q₁ q₂ d₁ d₂\n    @variable(model, 0 <= y₁ <= d₁)\n    @variable(model, 0 <= y₂ <= d₂)\n    @objective(model, Min, q₁*y₁ + q₂*y₂)\n    @constraint(model, 6*y₁ + 10*y₂ <= 60*x₁)\n    @constraint(model, 8*y₁ + 5*y₂ <= 80*x₂)\nend\n\nSee also: @first_stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@decision","page":"Public interface","title":"StochasticPrograms.@decision","text":"@decision(def)\n\nIn a @stage block, annotate each decision taken in the previous stage using the syntax\n\n@decision var1, var2, ...\n\nExamples\n\n@decision x₁, x₂\n\nSee also @parameters, @uncertain, @stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@parameters","page":"Public interface","title":"StochasticPrograms.@parameters","text":"@parameters(def)\n\nDefine the problem parameters in a @stage block\n\n@parameters param1, param2, ...\n\npossibly with default values. Any defined parameter without a default value must be supplied as a keyword argument to instantiate or SAA when creating models.\n\nExamples\n\n@parameters d\n\n@parameters begin\n    Crops = [:wheat, :corn, :beets]\n    Cost = Dict(:wheat=>150, :corn=>230, :beets=>260)\n    Budget = 500\nend\n\nSee also @decision, @uncertain, @stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@uncertain","page":"Public interface","title":"StochasticPrograms.@uncertain","text":"@uncertain(def)\n\nIn a @stage block, annotate each uncertain variable using the syntax\n\n@uncertain var1, var2, ...\n\nThis assumes that the [Scenario] type is used. Alternatively, user-defined scenarios can be specified by annotating the type. Also, inside a @stochastic_model block, user-defined scenarios can be created during the @uncertain annotation, following @scenario.\n\nExamples\n\n@uncertain q₁ q₂ d₁ d₂\n\n@scenario Simple = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend\n@uncertain ξ::SimpleScenario\n\n@stochastic_model begin\n    ...\n    @uncertain ξ::SimpleScenario = begin\n        q₁::Float64\n        q₂::Float64\n        d₁::Float64\n        d₂::Float64\n    end\n    ...\nend\n\nSee also @scenario, @parameters, @decision, @stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@stochastic_model","page":"Public interface","title":"StochasticPrograms.@stochastic_model","text":"@stochastic_model(def)\n\nDefine a stochastic model capable of instantiating stochastic programs, using the syntax\n\nsm = @stochastic_model begin\n    ...\n    @stage x begin\n      ...\n    end\n    ...\nend\n\nwhere the inner blocks are @stage blocks. At least two stages must be specified in consecutive order. A stochastic model object can later be used to instantiate stochastic programs using a given set of scenarios or to create SAA models using samplers.\n\nExamples\n\nThe following defines a stochastic model consisitng of the first stage model given by:\n\n  minimize 100x₁ + 150x₂\n    st  x₁ + x₂  120\n         x₁  40\n         x₂  20\n\nand the second-stage model given by:\n\n  minimize q₁(ξ)y₁ + q₂(ξ)y₂\n    st  6y₁ + 10y₂  60x₁\n         8y₁ + 5y₂  60x₂\n         0  y₁  d₁(ξ)\n         0  y₂  d₂(ξ)\n\nwhere q₁(ξ) q₂(ξ) d₁(ξ) d₂(ξ) depend on the scenario ξ.\n\nsm = @stochastic_model begin\n    @stage 1 begin\n        @variable(model, x₁ >= 40)\n        @variable(model, x₂ >= 20)\n        @objective(model, Min, 100*x₁ + 150*x₂)\n        @constraint(model, x₁ + x₂ <= 120)\n    end\n    @stage 2 begin\n        @decision x₁ x₂\n        @uncertain q₁ q₂ d₁ d₂\n        @variable(model, 0 <= y₁ <= d₁)\n        @variable(model, 0 <= y₂ <= d₂)\n        @objective(model, Min, q₁*y₁ + q₂*y₂)\n        @constraint(model, 6*y₁ + 10*y₂ <= 60*x₁)\n        @constraint(model, 8*y₁ + 5*y₂ <= 80*x₂)\n    end\nend\n\nSee also: @stage, @parameters, @decision, @uncertain\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#API","page":"Public interface","title":"API","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Modules = [StochasticPrograms]\nPages   = [\"api.jl\", \"stochasticsolution.jl\", \"SAA.jl\", \"generation.jl\", \"evaluation.jl\"]","category":"page"},{"location":"library/public/#StochasticPrograms.add_scenario!","page":"Public interface","title":"StochasticPrograms.add_scenario!","text":"add_scenario!(stochasticprogram::StochasticProgram, scenario::AbstractScenario, stage::Integer = 2; defer::Bool = false)\n\nStore the second stage scenario in the stochasticprogram at stage. Defaults to the second stage.\n\nIf defer is true, then model creation is deferred until generate!(stochasticprogram) is called. If the stochasticprogram is distributed, the scenario will be defined on the node that currently has the fewest scenarios.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.add_scenario!-2","page":"Public interface","title":"StochasticPrograms.add_scenario!","text":"add_scenario!(scenariogenerator::Function, stochasticprogram::StochasticProgram, stage::Integer = 2; defer::Bool = false)\n\nStore the second stage scenario returned by scenariogenerator in the second stage of the stochasticprogram. Defaults to the second stage.\n\nIf defer is true, then model creation is deferred until generate!(stochasticprogram) is called. If the stochasticprogram is distributed, the scenario will be defined on the node that currently has the fewest scenarios.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.add_scenarios!","page":"Public interface","title":"StochasticPrograms.add_scenarios!","text":"add_scenarios!(stochasticprogram::StochasticProgram, scenarios::Vector{<:AbstractScenario}, stage::Integer = 2; defer::Bool = false)\n\nStore the collection of second stage scenarios in the stochasticprogram at stage. Defaults to the second stage.\n\nIf defer is true, then model creation is deferred until generate!(stochasticprogram) is called. If the stochasticprogram is distributed, scenarios will be distributed evenly across workers.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.add_scenarios!-2","page":"Public interface","title":"StochasticPrograms.add_scenarios!","text":"add_scenarios!(scenariogenerator::Function, stochasticprogram::StochasticProgram, n::Integer, stage::Integer = 2; defer::Bool = false)\n\nGenerate n second-stage scenarios using scenariogeneratorand store in the stochasticprogram at stage. Defaults to the second stage.\n\nIf defer is true, then model creation is deferred until generate!(stochasticprogram) is called. If the stochasticprogram is distributed, scenarios will be distributed evenly across workers.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.add_worker_scenario!","page":"Public interface","title":"StochasticPrograms.add_worker_scenario!","text":"add_worker_scenario!(stochasticprogram::StochasticProgram, scenario::AbstractScenario, w::Integer, stage::Integer = 2; defer::Bool = false)\n\nStore the second stage scenario in worker node w of the stochasticprogram at stage. Defaults to the second stage.\n\nIf defer is true, then model creation is deferred until generate!(stochasticprogram) is called.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.add_worker_scenario!-2","page":"Public interface","title":"StochasticPrograms.add_worker_scenario!","text":"add_worker_scenario!(scenariogenerator::Function, stochasticprogram::StochasticProgram, w::Integer, stage::Integer = 2; defer::Bool = false)\n\nStore the second stage scenario returned by scenariogenerator in worker node w of the stochasticprogram at stage. Defaults to the second stage.\n\nIf defer is true, then model creation is deferred until generate!(stochasticprogram) is called.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.add_worker_scenarios!","page":"Public interface","title":"StochasticPrograms.add_worker_scenarios!","text":"add_worker_scenarios!(scenariogenerator::Function, stochasticprogram::StochasticProgram, n::Integer, w::Integer, stage::Integer = 2; defer::Bool = false)\n\nGenerate n second-stage scenarios using scenariogeneratorand store them in worker node w of the stochasticprogram at stage. Defaults to the second stage.\n\nIf defer is true, then model creation is deferred until generate!(stochasticprogram) is called.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.add_worker_scenarios!-2","page":"Public interface","title":"StochasticPrograms.add_worker_scenarios!","text":"add_worker_scenarios!(stochasticprogram::StochasticProgram, scenarios::Vector{<:AbstractScenario}, w::Integer, stage::Integer = 2; defer::Bool = false)\n\nStore the collection of second stage scenarios in in worker node w of the stochasticprogram at stage. Defaults to the second stage.\n\nIf defer is true, then model creation is deferred until generate!(stochasticprogram) is called.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.decision_length-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}","page":"Public interface","title":"StochasticPrograms.decision_length","text":"decision_length(stochasticprogram::TwoStageStochasticProgram)\n\nReturn the length of the first-stage decision of the two-stage stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.decision_length-Union{Tuple{N}, Tuple{StochasticProgram{N,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{Vararg{Stage,N}} where M,Integer}} where N","page":"Public interface","title":"StochasticPrograms.decision_length","text":"decision_length(stochasticprogram::StochasticProgram, s::Integer)\n\nReturn the length of the decision at stage s in the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.deferred-Union{Tuple{StochasticProgram{N,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{Vararg{Stage,N}} where M}, Tuple{N}} where N","page":"Public interface","title":"StochasticPrograms.deferred","text":"deferred(stochasticprogram::StochasticProgram)\n\nReturn true if stochasticprogram is not fully generated.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.distributed","page":"Public interface","title":"StochasticPrograms.distributed","text":"distributed(stochasticprogram::StochasticProgram, s::Integer = 2)\n\nReturn true if the stochasticprogram is memory distributed at stage s. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.expected","page":"Public interface","title":"StochasticPrograms.expected","text":"expected(stochasticprogram::StochasticProgram, s::Integer = 2)\n\nReturn the exected scenario of all scenarios of the stochasticprogram at stage s. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.first_stage_dims-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.first_stage_dims","text":"first_stage_dims(stochasticprogram::StochasticProgram)\n\nReturn a the number of variables and the number of constraints in the the first stage of stochasticprogram as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.first_stage_nconstraints-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.first_stage_nconstraints","text":"first_stage_nconstraints(stochasticprogram::StochasticProgram)\n\nReturn the number of constraints in the the first stage of stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.generator-Tuple{StochasticProgram,Symbol}","page":"Public interface","title":"StochasticPrograms.generator","text":"generator(stochasticprogram::StochasticProgram, key::Symbol)\n\nReturn the problem generator associated with key in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.has_generator-Tuple{StochasticProgram,Symbol}","page":"Public interface","title":"StochasticPrograms.has_generator","text":"has_generator(stochasticprogram::StochasticProgram, key::Symbol)\n\nReturn true if a problem generator with key exists in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.instantiate-Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},Array{#s39,1} where #s39<:AbstractScenario}","page":"Public interface","title":"StochasticPrograms.instantiate","text":"instantiate(stochasticmodel::StochasticModel{2},\n            scenarios::Vector{<:AbstractScenario};\n            solver = JuMP.UnsetSolver(),\n            procs = workers(),\n            kw...)\n\nInstantiate a new two-stage stochastic program using the model definition stored in the two-stage stochasticmodel, and the given collection of scenarios.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.instantiate-Union{Tuple{M}, Tuple{N}, Tuple{StochasticModel{N,P} where P<:Tuple{Vararg{StageParameters,N}},Tuple{Vararg{Array{#s39,1} where #s39<:AbstractScenario,M}}}} where M where N","page":"Public interface","title":"StochasticPrograms.instantiate","text":"instantiate(stochasticmodel::StochasticModel,\n            scenarios::Vector{<:AbstractScenario};\n            solver = JuMP.UnsetSolver(),\n            procs = workers(),\n            kw...)\n\nInstantiate a new stochastic program using the model definition stored in stochasticmodel, and the given collection of scenarios.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.instantiate-Union{Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters}}, Tuple{S}} where S<:AbstractScenario","page":"Public interface","title":"StochasticPrograms.instantiate","text":"instantiate(stochasticmodel::StochasticModel{2};\n            scenariotype::Type{S} = Scenario,\n            solver = JuMP.UnsetSolver(),\n            procs = workers(),\n            kw...) where S <: AbstractScenario\n\nInstantiate a deferred two-stage stochastic program using the model definition stored in the two-stage stochasticmodel over the scenario type S.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.masterterms","page":"Public interface","title":"StochasticPrograms.masterterms","text":"masterterms(stochasticprogram::StochasticProgram, i::Integer, s::Integer = 2)\n\nReturn the first stage terms appearing in scenario i in the stochasticprogram at stage s. Defaults to the second stage.\n\nThe master terms are given in sparse format as an array of tuples (row,col,coeff) which specify the occurance of master problem variables in the second stage constraints.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.nscenarios","page":"Public interface","title":"StochasticPrograms.nscenarios","text":"nscenarios(stochasticprogram::StochasticProgram, s::Integer = 2)\n\nReturn the number of scenarios in the stochasticprogram at stage s. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.nstages-Union{Tuple{StochasticProgram{N,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{Vararg{Stage,N}} where M}, Tuple{N}} where N","page":"Public interface","title":"StochasticPrograms.nstages","text":"nstages(stochasticprogram::StochasticProgram)\n\nReturn the number of stages in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.nsubproblems","page":"Public interface","title":"StochasticPrograms.nsubproblems","text":"nsubproblems(stochasticprogram::StochasticProgram, s::Integer = 2)\n\nReturn the number of subproblems in the stochasticprogram at stage s. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.optimal_decision-Tuple{StochasticProgram,Integer,Symbol}","page":"Public interface","title":"StochasticPrograms.optimal_decision","text":"optimal_decision(stochasticprogram::StochasticProgram, var::Symbol)\n\nReturn the optimal second stage variable var of stochasticprogram in the ith scenario, after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimal_decision-Tuple{StochasticProgram,Integer}","page":"Public interface","title":"StochasticPrograms.optimal_decision","text":"optimal_decision(stochasticprogram::StochasticProgram, i::Integer)\n\nReturn the optimal second stage decision of stochasticprogram in the ith scenario, after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimal_decision-Tuple{StochasticProgram,Symbol}","page":"Public interface","title":"StochasticPrograms.optimal_decision","text":"optimal_decision(stochasticprogram::StochasticProgram, var::Symbol)\n\nReturn the optimal first stage variable var of stochasticprogram, after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimal_decision-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.optimal_decision","text":"optimal_decision(stochasticprogram::StochasticProgram)\n\nReturn the optimal first stage decision of stochasticprogram, after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimal_value-Tuple{StochasticProgram,Integer}","page":"Public interface","title":"StochasticPrograms.optimal_value","text":"optimal_value(stochasticprogram::StochasticProgram, i::Integer)\n\nReturn the optimal value of the ith subproblem in stochasticprogram, after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimal_value-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.optimal_value","text":"optimal_value(stochasticprogram::StochasticProgram)\n\nReturn the optimal value of stochasticprogram, after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimize!-Tuple{StochasticModel,AbstractSampler}","page":"Public interface","title":"StochasticPrograms.optimize!","text":"optimize!(stochasticmodel::StochasticModel, sampler::AbstractSampler; solver::SPSolverType = JuMP.UnsetSolver(), confidence::AbstractFloat = 0.95, kwargs...)\n\nApproximately optimize the stochasticmodel using solver when the underlying scenario distribution is inferred by sampler and return a StochasticSolution with the given confidence level.\n\nSee also: StochasticSolution\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimize!-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}","page":"Public interface","title":"StochasticPrograms.optimize!","text":"optimize!(stochasticprogram::StochasticProgram; solver::SPSolverType = JuMP.UnsetSolver())\n\nOptimize the stochasticprogram in expectation using solver.\n\nExamples\n\nThe following solves the stochastic program sp using the L-shaped algorithm.\n\nusing LShapedSolvers\nusing GLPKMathProgInterface\n\noptimize!(sp, solver = LShapedSolver(:ls, GLPKSolverLP()));\n\n# output\n\nL-Shaped Gap  Time: 0:00:01 (4 iterations)\n  Objective:       -855.8333333333339\n  Gap:             0.0\n  Number of cuts:  7\n:Optimal\n\nThe following solves the stochastic program sp using GLPK on the extended form.\n\nusing GLPKMathProgInterface\n\noptimize!(sp, solver = GLPKSolverLP())\n\n:Optimal\n\nSee also: VRP\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.probability","page":"Public interface","title":"StochasticPrograms.probability","text":"probability(stochasticprogram::StochasticProgram, i::Integer, s::Integer = 2)\n\nReturn the probability of scenario ith scenario in the stochasticprogram at stage s occuring. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.recourse_length-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}","page":"Public interface","title":"StochasticPrograms.recourse_length","text":"recourse_length(stochasticprogram::TwoStageStochasticProgram)\n\nReturn the length of the second-stage decision in the two-stage stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.sample!","page":"Public interface","title":"StochasticPrograms.sample!","text":"sample!(stochasticprogram::StochasticProgram, sampler::AbstractSampler, n::Integer, stage::Integer = 2; defer::Bool = false)\n\nSample n scenarios using sampler and add to the stochasticprogram at stage. Defaults to the second stage.\n\nIf defer is true, then model creation is deferred until generate!(stochasticprogram) is called. If the stochasticprogram is distributed, scenarios will be distributed evenly across workers.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.sample-Union{Tuple{S}, Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},AbstractSampler{S},Integer}} where S<:AbstractScenario","page":"Public interface","title":"StochasticPrograms.sample","text":"sample(stochasticmodel::StochasticModel, sampler::AbstractSampler, n::Integer; solver = JuMP.UnsetSolver())\n\nGenerate a sampled instance of size n using the model stored in the two-stage stochasticmodel, and the provided sampler.\n\nOptionally, a capable solver can be supplied to sample. Otherwise, any previously set solver will be used.\n\nSee also: sample!\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.scenario","page":"Public interface","title":"StochasticPrograms.scenario","text":"scenario(stochasticprogram::StochasticProgram, i::Integer, s::Integer = 2)\n\nReturn the ith scenario of stochasticprogramat stages`. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.scenarioproblems","page":"Public interface","title":"StochasticPrograms.scenarioproblems","text":"scenarioproblems(stochasticprogram::TwoStageStochasticProgram)\n\nReturn the scenario problems in stochasticprogram.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.scenarioproblems-Union{Tuple{N}, Tuple{StochasticProgram{N,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{Vararg{Stage,N}} where M,Integer}} where N","page":"Public interface","title":"StochasticPrograms.scenarioproblems","text":"scenarioproblems(stochasticprogram::StochasticProgram, s::Integer)\n\nReturn the scenario problems at stage s in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.scenarios","page":"Public interface","title":"StochasticPrograms.scenarios","text":"scenarios(stochasticprogram::StochasticProgram, s::Integer = 2)\n\nReturn an array of all scenarios of the stochasticprogram at stage s. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.scenariotype","page":"Public interface","title":"StochasticPrograms.scenariotype","text":"scenariotype(stochasticprogram::StochasticProgram, s::Integer = 2)\n\nReturn the type of the scenario structure associated with stochasticprogram at stage s. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.set_spsolver-Tuple{StochasticProgram,Union{AbstractMathProgSolver, AbstractStructuredSolver}}","page":"Public interface","title":"StochasticPrograms.set_spsolver","text":"set_spsolver(stochasticprogram::StochasticProgram, spsolver::Union{MathProgBase.AbstractMathProgSolver,AbstractStructuredSolver})\n\nStore the stochastic program solver spsolver of the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.spsolver-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.spsolver","text":"spsolver(stochasticprogram::StochasticProgram)\n\nReturn the stochastic program solver spsolver of the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.spsolver_model-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.spsolver_model","text":"internal_model(stochasticprogram::StochasticProgram)\n\nReturn the internal solve model object of the stochasticprogram, after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.stage_parameters-Union{Tuple{N}, Tuple{StochasticProgram{N,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{Vararg{Stage,N}} where M,Integer}} where N","page":"Public interface","title":"StochasticPrograms.stage_parameters","text":"stage_parameters(stochasticprogram::StochasticProgram, s::Integer)\n\nReturn the parameters at stage s in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.stage_probability","page":"Public interface","title":"StochasticPrograms.stage_probability","text":"stage_probability(stochasticprogram::StochasticProgram, s::Integer = 2)\n\nReturn the probability of any scenario in the stochasticprogram at stage s occuring. A well defined model should return 1. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.subproblem","page":"Public interface","title":"StochasticPrograms.subproblem","text":"subproblem(stochasticprogram::StochasticProgram, i::Integer, s::Integer = 2)\n\nReturn the ith subproblem of the stochasticprogram at stage s. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.subproblems","page":"Public interface","title":"StochasticPrograms.subproblems","text":"subproblems(stochasticprogram::StochasticProgram, s::Integer = 2)\n\nReturn an array of all subproblems of the stochasticprogram at stage s. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.ConfidenceInterval","page":"Public interface","title":"StochasticPrograms.ConfidenceInterval","text":"ConfidenceInterval\n\nAn estimated interval around an unknown quantity at a given confidence level\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.StochasticSolution","page":"Public interface","title":"StochasticPrograms.StochasticSolution","text":"StochasticSolution\n\nApproximate solution to a stochastic model to a given level of confidence.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.confidence_interval-Tuple{StochasticSolution}","page":"Public interface","title":"StochasticPrograms.confidence_interval","text":"confidence_interval(solution::StochasticSolution)\n\nReturn a confidence interval around the optimal value of the approximate solution to some stochastic model\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.decision-Tuple{StochasticSolution}","page":"Public interface","title":"StochasticPrograms.decision","text":"decision(solution::StochasticSolution)\n\nReturn the optimal first stage decision of the approximate solution to some stochastic model.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimal_value-Tuple{StochasticSolution}","page":"Public interface","title":"StochasticPrograms.optimal_value","text":"optimal_value(solution::StochasticSolution)\n\nReturn the optimal value of the approximate solution to some stochastic model\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.SAA","page":"Public interface","title":"StochasticPrograms.SAA","text":"SAA\n\nDefault SampledSolver. Generates a StochasticSolution using the sample average approximation (SAA) method, to the desired confidence level.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.SAA-Tuple{}","page":"Public interface","title":"StochasticPrograms.SAA","text":"SAA(; solver::SPSolverType = JuMP.UnsetSolver())\n\nReturn an SAA where the emerging SAA problems are solved using solver.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.generate!-Union{Tuple{StochasticProgram{N,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{Vararg{Stage,N}} where M}, Tuple{N}} where N","page":"Public interface","title":"StochasticPrograms.generate!","text":"generate!(stochasticprogram::StochasticProgram)\n\nGenerate the stochasticprogram using the model definitions from @stage and available data.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.outcome_model-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M,AbstractArray{T,1} where T,AbstractScenario}","page":"Public interface","title":"StochasticPrograms.outcome_model","text":"outcome_model(stochasticprogram::TwoStageStochasticProgram,\n              decision::AbstractVector,\n              scenario::AbstractScenario;\n              solver::MathProgBase.AbstractMathProgSolver = JuMP.UnsetSolver())\n\nReturn the resulting second stage model if decision is the first-stage decision in scenario i, in stochasticprogram. Optionally, supply a capable solver to the outcome model.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.outcome_model-Union{Tuple{M}, Tuple{N}, Tuple{StochasticProgram{N,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{Vararg{Stage,N}} where M,Tuple{Vararg{AbstractArray{T,1} where T,M}},Tuple{Vararg{AbstractScenario,M}}}} where M where N","page":"Public interface","title":"StochasticPrograms.outcome_model","text":"outcome_model(stochasticprogram::StochasticProgram{N},\n              decisions::NTuple{N-1,AbstractVector}\n              scenario_path::NTuple{N-1,AbstractScenario},\n              solver::MathProgBase.AbstractMathProgSolver = JuMP.UnsetSolver())\n\nReturn the resulting N:th stage model if decisions are the decisions taken in the previous stages and scenario_path are the realized scenarios up to stage N in stochasticprogram. Optionally, supply a capable solver to the outcome model.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.stage_model-Union{Tuple{N}, Tuple{StochasticProgram{N,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{Vararg{Stage,N}} where M,Integer,AbstractScenario}} where N","page":"Public interface","title":"StochasticPrograms.stage_model","text":"stage_two_model(stochasticprogram::StochasticProgram)\n\nReturn a generated second stage model corresponding to scenario, in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.stage_one_model-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.stage_one_model","text":"stage_one_model(stochasticprogram::StochasticProgram)\n\nReturn a generated copy of the first stage model in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.confidence_interval-Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},AbstractSampler}","page":"Public interface","title":"StochasticPrograms.confidence_interval","text":"confidence_interval(stochasticmodel::StochasticModel{2},\n                    sampler::AbstractSampler;\n                    solver = JuMP.UnsetSolver(),\n                    confidence = 0.9,\n                    N = 100,\n                    M = 10,\n                    T = 10)\n\nGenerate a confidence interval around the true optimum of the two-stage stochasticmodel at level confidence using SAA, over the scenario distribution induced by sampler.\n\nN is the size of the sampled models used to generate the interval and generally governs how tight it is. M is the number of sampled models used in the lower bound calculation, and T is the number of sampled models used in the upper bound calculation.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.evaluate_decision-Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},AbstractArray{T,1} where T,AbstractSampler}","page":"Public interface","title":"StochasticPrograms.evaluate_decision","text":"evaluate_decision(stochasticmodel::StochasticModel{2},\n                  decision::AbstractVector,\n                  sampler::AbstractSampler;\n                  solver = JuMP.UnsetSolver(),\n                  confidence = 0.95,\n                  N = 1000)\n\nReturn a statistical estimate of the objective of the two-stage stochasticmodel at decision in the form of a confidence interval at level confidence, over the scenario distribution induced by sampler.\n\nIn other words, evaluate decision on a sampled model of size N. Generate an confidence interval using the sample variance of the evaluation.\n\nSee also: confidence_interval\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.evaluate_decision-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M,AbstractArray{T,1} where T,AbstractScenario}","page":"Public interface","title":"StochasticPrograms.evaluate_decision","text":"evaluate_decision(stochasticprogram::TwoStageStochasticProgram,\n                  decision::AbstractVector,\n                  scenario::AbstractScenario;\n                  solver = JuMP.UnsetSolver())\n\nEvaluate the result of taking the first-stage decision if scenario is the actual outcome in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.evaluate_decision-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M,AbstractArray{T,1} where T}","page":"Public interface","title":"StochasticPrograms.evaluate_decision","text":"evaluate_decision(stochasticprogram::TwoStageStochasticProgram,\n                  decision::AbstractVector;\n                  solver = JuMP.UnsetSolver())\n\nEvaluate the first-stage decision in stochasticprogram.\n\nIn other words, evaluate the first-stage objective at decision and solve outcome models of decision for every available scenario. Optionally, supply a capable solver to solve the outcome models. Otherwise, any previously set solver will be used.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.gap-Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},AbstractArray{T,1} where T,AbstractSampler}","page":"Public interface","title":"StochasticPrograms.gap","text":"gap(stochasticmodel::StochasticModel{2},\n    x::AbstractVector,\n    sampler::AbstractSampler;\n    solver = JuMP.UnsetSolver(),\n    confidence = 0.9,\n    N = 100,\n    M = 10,\n    T = 10)\n\nGenerate a confidence interval around the gap between the result of using decison x and true optimum of the two-stage stochasticmodel at level confidence using SAA, over the scenario distribution induced by sampler.\n\nN is the size of the SAA models used to generate the interval and generally governs how tight it is. M is the number of sampled models used in the lower bound calculation, and T is the number of sampled models used in the upper bound calculation.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.lower_bound-Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},AbstractSampler}","page":"Public interface","title":"StochasticPrograms.lower_bound","text":"lower_bound(stochasticmodel::StochasticModel{2},\n            sampler::AbstractSampler;\n            solver = JuMP.UnsetSolver(),\n            confidence = 0.95,\n            N = 100,\n            M = 10)\n\nGenerate a confidence interval around a lower bound on the true optimum of the two-stage stochasticmodel at level confidence, over the scenario distribution induced by sampler.\n\nN is the size of the sampled models used to generate the interval and generally governs how tight it is. M is the number of sampled models.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.upper_bound-Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},AbstractArray{T,1} where T,AbstractSampler}","page":"Public interface","title":"StochasticPrograms.upper_bound","text":"upper_bound(stochasticmodel::StochasticModel{2},\n            x::AbstractVector,\n            sampler::AbstractSampler;\n            solver = JuMP.UnsetSolver(),\n            confidence = 0.95,\n            T = 10,\n            Ñ = 1000)\n\nGenerate a confidence interval around an upper bound of the expected value of the decision x in the two-stage stochasticmodel at level confidence, over the scenario distribution induced by sampler.\n\nÑ is the size of each sampled model and T is the number of sampled models.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.upper_bound-Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},AbstractSampler}","page":"Public interface","title":"StochasticPrograms.upper_bound","text":"upper_bound(stochasticmodel::StochasticModel{2},\n            sampler::AbstractSampler;\n            solver = JuMP.UnsetSolver(),\n            confidence = 0.95,\n            N = 100,\n            T = 10,\n            n = 1000)\n\nGenerate a confidence interval around an upper of the true optimum of the two-stage stochasticmodel at level confidence, over the scenario distribution induced by sampler.\n\nN is the size of the sampled model used to generate a candidate decision. Ñ is the size of each sampled model and T is the number of sampled models.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Stochastic-programming-constructs","page":"Public interface","title":"Stochastic programming constructs","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Modules = [StochasticPrograms]\nPages   = [\"spconstructs.jl\"]","category":"page"},{"location":"library/public/#StochasticPrograms.DEP-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}","page":"Public interface","title":"StochasticPrograms.DEP","text":"DEP(stochasticprogram::TwoStageStochasticProgram; solver = JuMP.UnsetSolver())\n\nGenerate the deterministically equivalent problem (DEP) of the two-stage stochasticprogram.\n\nIn other words, generate the extended form the stochasticprogram as a single JuMP model. Optionally, a capable solver can be supplied to DEP. Otherwise, any previously set solver will be used.\n\nSee also: VRP, WS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EEV-Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},AbstractSampler}","page":"Public interface","title":"StochasticPrograms.EEV","text":"EEV(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler; solver = JuMP.UnsetSolver(), confidence = 0.95, N::Integer = 100, Ñ::Integer = 1000)\n\nApproximately calculate the expected value of the expected value decision (EEV) of the two-stage stochasticmodel to the given confidence level, over the scenario distribution induced by sampler.\n\nSupply a capable solver to solve the intermediate problems. N is the number of scenarios to sample in order to determine the EVP decision and Ñ is the number of samples in the out-of-sample evaluation of the EVP decision.\n\nSee also: EVP, EV\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EEV-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}","page":"Public interface","title":"StochasticPrograms.EEV","text":"EEV(stochasticprogram::TwoStageStochasticProgram; solver = JuMP.UnsetSolver())\n\nCalculate the expected value of the expected value solution (EEV) of the two-stage stochasticprogram.\n\nIn other words, evaluate the EVP decision. Optionally, supply a capable solver to solve the intermediate problems. The default behaviour is to rely on any previously set solver.\n\nSee also: EVP, EV\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EV-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}","page":"Public interface","title":"StochasticPrograms.EV","text":"EV(stochasticprogram::TwoStageStochasticProgram; solver = JuMP.UnsetSolver())\n\nCalculate the optimal value of the EVP of the two-stage stochasticprogram.\n\nOptionally, supply a capable solver to solve the expected value problem. The default behaviour is to rely on any previously set solver.\n\nSee also: EVP, EVP_decision, EEV\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EVP-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}","page":"Public interface","title":"StochasticPrograms.EVP","text":"EVP(stochasticprogram::TwoStageStochasticProgram; solver = JuMP.UnsetSolver())\n\nGenerate the expected value problem (EVP) of the two-stage stochasticprogram.\n\nIn other words, generate a wait-and-see model corresponding to the expected scenario over all available scenarios in stochasticprogram. Optionally, supply a capable solver to EVP. Otherwise, any previously set solver will be used.\n\nSee also: EVP_decision, EEV, EV, WS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EVPI-Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},AbstractSampler}","page":"Public interface","title":"StochasticPrograms.EVPI","text":"EVPI(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler; solver = JuMP.UnsetSolver(), confidence = 0.95)\n\nApproximately calculate the expected value of perfect information (EVPI) of the two-stage stochasticmodel to the given confidence level, over the scenario distribution induced by sampler.\n\nIn other words, calculate confidence intervals around VRP and EWS. If they do not overlap, the EVPI is statistically significant, and a confidence interval is calculated and returned. Optionally, supply a capable solver to solve the intermediate problems. Otherwise, any previously set solver will be used.\n\nSee also: VRP, EWS, VSS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EVPI-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}","page":"Public interface","title":"StochasticPrograms.EVPI","text":"EVPI(stochasticprogram::TwoStageStochasticProgram; solver = JuMP.UnsetSolver())\n\nCalculate the expected value of perfect information (EVPI) of the two-stage stochasticprogram.\n\nIn other words, calculate the gap between VRP and EWS. Optionally, supply a capable solver to solve the intermediate problems. Otherwise, any previously set solver will be used.\n\nSee also: VRP, EWS, VSS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EVP_decision-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}","page":"Public interface","title":"StochasticPrograms.EVP_decision","text":"EVP_decision(stochasticprogram::TwoStageStochasticProgram; solver = JuMP.UnsetSolver())\n\nCalculate the optimizer of the EVP of the two-stage stochasticprogram.\n\nOptionally, supply a capable solver to solve the expected value problem. The default behaviour is to rely on any previously set solver.\n\nSee also: EVP, EV, EEV\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EWS-Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},AbstractSampler}","page":"Public interface","title":"StochasticPrograms.EWS","text":"EWS(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler; solver = JuMP.UnsetSolver(), confidence = 0.95, N::Integer = 1000)\n\nApproximately calculate the expected wait-and-see result (EWS) of the two-stage stochasticmodel to the given confidence level, over the scenario distribution induced by sampler.\n\nSupply a capable solver to solve the intermediate problems. N is the number of scenarios to sample.\n\nSee also: VRP, WS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EWS-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}","page":"Public interface","title":"StochasticPrograms.EWS","text":"EWS(stochasticprogram::StochasticProgram; solver = JuMP.UnsetSolver())\n\nCalculate the expected wait-and-see result (EWS) of the stochasticprogram.\n\nIn other words, calculate the expectated result of all possible wait-and-see models, using the provided scenarios in stochasticprogram. Optionally, a capable solver can be supplied to solve the intermediate problems. Otherwise, any previously set solver will be used.\n\nSee also: VRP, WS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.VRP-Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},AbstractSampler}","page":"Public interface","title":"StochasticPrograms.VRP","text":"VRP(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler; solver = JuMP.UnsetSolver(), confidence = 0.95)\n\nReturn a confidence interval around the value of the recouse problem (VRP) of stochasticmodel to the given confidence level.\n\nOptionally, supply a capable solver to optimize the stochastic program. Otherwise, any previously set solver will be used.\n\nSee also: EVPI, VSS, EWS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.VRP-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.VRP","text":"VRP(stochasticprogram::StochasticProgram; solver = JuMP.UnsetSolver())\n\nCalculate the value of the recouse problem (VRP) in stochasticprogram.\n\nIn other words, optimize the stochastic program and return the optimal value. Optionally, supply a capable solver to optimize the stochastic program. Otherwise, any previously set solver will be used.\n\nSee also: EVPI, EWS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.VSS-Tuple{StochasticModel{2,P} where P<:Tuple{StageParameters,StageParameters},AbstractSampler}","page":"Public interface","title":"StochasticPrograms.VSS","text":"VSS(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler; solver = JuMP.UnsetSolver(), confidence = 0.95, Ñ::Integer = 1000)\n\nApproximately calculate the value of the stochastic solution (VSS) of the two-stage stochasticmodel to the given confidence level, over the scenario distribution induced by sampler.\n\nIn other words, calculate confidence intervals around EEV and VRP. If they do not overlap, the VSS is statistically significant, and a confidence interval is calculated and returned. Optionally, supply a capable solver to solve the intermediate problems. Otherwise, any previously set solver will be used. Ñ is the number of samples in the out-of-sample evaluation of EEV.\n\nSee also: VRP, EEV, EVPI\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.VSS-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M}","page":"Public interface","title":"StochasticPrograms.VSS","text":"VSS(stochasticprogram::TwoStageStochasticProgram; solver = JuMP.UnsetSolver())\n\nCalculate the value of the stochastic solution (VSS) of the two-stage stochasticprogram.\n\nIn other words, calculate the gap between EEV and VRP. Optionally, supply a capable solver to solve the intermediate problems. The default behaviour is to rely on any previously set solver.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.WS-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M,AbstractScenario}","page":"Public interface","title":"StochasticPrograms.WS","text":"WS(stochasticprogram::TwoStageStochasticProgram, scenario::AbstractScenarioaData; solver = JuMP.UnsetSolver())\n\nGenerate a wait-and-see (WS) model of the two-stage stochasticprogram, corresponding to scenario.\n\nIn other words, generate the first stage and the second stage of the stochasticprogram as if scenario is known to occur. Optionally, a capable solver can be supplied to WS. Otherwise, any previously set solver will be used.\n\nSee also: DEP, EVP\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.WS_decision-Tuple{StochasticProgram{2,M,S,SP} where SP<:Union{Tuple{Vararg{AbstractScenarioProblems,M}}, AbstractScenarioProblems} where S<:Tuple{StochasticPrograms.Stage,StochasticPrograms.Stage} where M,AbstractScenario}","page":"Public interface","title":"StochasticPrograms.WS_decision","text":"WS_decision(stochasticprogram::TwoStageStochasticProgram, scenario::AbstractScenario; solver = JuMP.UnsetSolver())\n\nCalculate the optimizer of the wait-and-see (WS) model of the two-stage stochasticprogram, corresponding to scenario.\n\nOptionally, supply a capable solver to solve the wait-and-see problem. The default behaviour is to rely on any previously set solver.\n\nSee also: WS\n\n\n\n\n\n","category":"method"},{"location":"manual/structuredsolvers/#Structured-solvers","page":"Structured solvers","title":"Structured solvers","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"A stochastic program has a structure that can be exploited in solver algorithms through decomposition. This can heavily reduce the computation time required to optimize the stochastic program, compared to solving the extensive form directly. Moreover, a distributed stochastic program is by definition decomposed and a structured solver that can operate in parallel will be much more efficient.","category":"page"},{"location":"manual/structuredsolvers/#Solver-interface","page":"Structured solvers","title":"Solver interface","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The structured solver interface mimics that of MathProgBase, and it needs to be implemented by any structured solver to be compatible with StochasticPrograms. We distinguish between structure-exploiting solvers for solving finite stochastic programs and sampled-bases solvers for approximately solving stochastic models, even though they can be based on the same algorithm.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Some procedures in StochasticPrograms require a MathProgBase solver. It is common that structured solvers rely internally on some MathProgBase solver. Hence, for convenience, a solver can implement internal_solver to return any internal MathProgBase solver. A stochastic program that has an loaded structured solver that implements this method can then make use of that solver for those procedures, instead of requiring an external solver to be supplied. Finally, a structured solver can optionally implement solverstr to return an informative description string for printouts.","category":"page"},{"location":"manual/structuredsolvers/#Stochastic-programs","page":"Structured solvers","title":"Stochastic programs","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"To interface a new structure-exploiting solver, define a shallow object of type AbstractStructuredSolver. This object is intended to be the interface to end users of the solver and is what should be passed to optimize!. Define a new structured solver as a subtype of AbstractStructuredModel. Next, implement StructuredModel, that takes the stochastic program and the AbstractStructuredSolver object and return an instance of AbstractStructuredModel which internal state depends on the given stochastic program. Next, the solver algorithm should be run when calling optimize_structured! on the AbstractStructuredModel. After successfuly optimizing the model, the solver must be able to fill in the optimal solution in the first stage and all second stages through fill_solution!.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"In summary, the solver interface that a new AbstractStructuredModel and AbstractStructuredSolver pair should adhere to is given by","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"StructuredModel\noptimize_structured!\nfill_solution!\ninternal_solver\nsolverstr","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"As an example, a simplified version of the implementation of the structured solver interface for LShaped is given below:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"abstract AbstractLShapedSolver <: AbstractStructuredModel end\n\nconst MPB = MathProgBase\n\nmutable struct LShapedSolver <: AbstractStructuredSolver\n    lpsolver::MPB.AbstractMathProgSolver\n    subsolver::S\n    feasibility_cuts::Bool\n    execution::E\n    regularize::R\n    aggregate::A\n    consolidate::C\n    crash::CrashMethod\n    parameters::Dict{Symbol,Any}\n\n    function LShapedSolver(lpsolver::MPB.AbstractMathProgSolver;\n                           execution::Execution = Serial(),\n                           feasibility_cuts::Bool = true,\n                           regularize::AbstractRegularizer = DontRegularize(),\n                           aggregate::AbstractAggregator = DontAggregate(),\n                           consolidate::AbstractConsolidator = DontConsolidate(),\n                           crash::CrashMethod = Crash.None(),\n                           subsolver::SubSolver = lpsolver, kwargs...)\n        return new(lpsolver, subsolver, feasibility_cuts, execution, regularize, aggregate, consolidate, crash, Dict{Symbol,Any}(kwargs))\n    end\nend\n\nfunction StructuredModel(stochasticprogram::StochasticProgram, solver::LShapedSolver)\n    x₀ = solver.crash(stochasticprogram, solver.lpsolver)\n    return LShaped(stochasticprogram, x₀, solver.lpsolver, get_solver(solver.subsolver), solver.feasibility_cuts, solver.execution, solver.regularize, solver.aggregate, solver.consolidate; solver.parameters...)\nend\n\nfunction internal_solver(solver::LShapedSolver)\n    return solver.lpsolver\nend\n\nfunction optimize_structured!(lshaped::AbstractLShapedSolver)\n    return lshaped()\nend\n\nfunction fill_solution!(stochasticprogram::StochasticProgram, lshaped::AbstractLShapedSolver)\n    # First stage\n    first_stage = StochasticPrograms.get_stage_one(stochasticprogram)\n    nrows, ncols = first_stage_dims(stochasticprogram)\n    StochasticPrograms.set_decision!(stochasticprogram, decision(lshaped))\n    μ = try\n        MPB.getreducedcosts(lshaped.mastersolver.lqmodel)[1:ncols]\n    catch\n        fill(NaN, ncols)\n    end\n    StochasticPrograms.set_first_stage_redcosts!(stochasticprogram, μ)\n    λ = try\n        MPB.getconstrduals(lshaped.mastersolver.lqmodel)[1:nrows]\n    catch\n        fill(NaN, nrows)\n    end\n    StochasticPrograms.set_first_stage_duals!(stochasticprogram, λ)\n    # Second stage\n    fill_submodels!(lshaped, scenarioproblems(stochasticprogram))\nend\n\nfunction solverstr(solver::LShapedSolver)\n    return \"L-shaped solver\"\nend","category":"page"},{"location":"manual/structuredsolvers/#Stochastic-models","page":"Structured solvers","title":"Stochastic models","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"To interface a new sampled-based solver, define a shallow object of type AbstractSampledSolver. This object is intended to be the interface to end users of the solver and is what should be passed to optimize!.Similar to finite programs, define a new sampled-based solver as a subtype of AbstractSampledModel. Next, implement SampledModel, that takes a stochastic model and the AbstractStructuredSolver object and returns an instance of AbstractSampledModel. Next, the solver algorithm should be run when calling optimize_sampled! on the AbstractSampledModel, some AbstractSampler and a desired confidence level. After successfuly optimizing the model, a StochasticSolution should be retrivable from the AbstractSampledModel using stochastic_solution","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"In summary, the solver interface that a new AbstractSampledModel and AbstractStructuredSolver pair should adhere to is given by","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"SampledModel\noptimize_sampled!\nstochastic_solution\ninternal_solver\nsolverstr","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"As an example, consider the implementation of SAA:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"struct SAA{S <: SPSolverType} <: AbstractStructuredSolver\n    internal_solver::S\n\n    function SAA(solver::SPSolverType)\n        if isa(solver, JuMP.UnsetSolver)\n            error(\"Cannot solve emerging SAA problems without functional solver.\")\n        end\n        S = typeof(solver)\n        return new{S}(solver)\n    end\nend\nfunction SAA(; solver::SPSolverType = JuMP.UnsetSolver())\n    return SAA(solver)\nend\n\nmutable struct SAAModel{M <: StochasticModel, S <: SPSolverType} <: AbstractSampledModel\n    stochasticmodel::M\n    solver::S\n    solution::StochasticSolution\nend\n\nfunction SampledModel(stochasticmodel::StochasticModel, solver::SAA)\n    return SAAModel(stochasticmodel, solver.internal_solver, EmptySolution())\nend\n\nfunction optimize_sampled!(saamodel::SAAModel, sampler::AbstractSampler, confidence::AbstractFloat; M::Integer = 10, tol::AbstractFloat = 1e-1, Nmax::Integer = 5000)\n    sm = saamodel.stochasticmodel\n    solver = saamodel.solver\n    n = 16\n    α = 1-confidence\n    while true\n        CI = confidence_interval(sm, sampler; solver = solver, confidence = 1-α, N = N, M = M, Ñ = max(N, Ñ), T = T)\n        Q = (upper(CI) + lower(CI))/2\n        gap = length(CI)/abs(Q+1e-10)\n        if gap <= tol\n            sp = sample(sm, sampler, N)\n            optimize!(sp, solver = solver)\n            Q = optimal_value(sp)\n            while !(Q ∈ CI)\n                sp = sample(sm, sampler, N)\n                optimize!(sp, solver = solver)\n                Q = optimal_value(sp)\n            end\n            saamodel.solution = StochasticSolution(optimal_decision(saa), Q, N, CI)\n            saamodel.saa = saa\n            return :Optimal\n        end\n        N = N * 2\n        if N > Nmax\n            return :LimitReached\n        end\n        solver_config(solver, N)\n    end\nend\n\nfunction stochastic_solution(saamodel::SAAModel)\n    return saamodel.solution\nend","category":"page"},{"location":"manual/structuredsolvers/#L-shaped-solvers","page":"Structured solvers","title":"L-shaped solvers","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"StochasticPrograms includes a collection of L-shaped algorithms in the submodule LShapedSolvers. All algorithm variants are based on the L-shaped method by Van Slyke and Wets. LShapedSolvers interfaces with StochasticPrograms through the structured solver interface. Every algorithm variant is an instance of the functor object LShaped, and are instanced using the factory object LShapedSolver.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"As an example, we solve the simple problem introduced in the Quick start:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"using LShapedSolvers\nusing GLPKMathProgInterface\n\noptimize!(sp, solver = LShapedSolver(GLPKSolverLP()))","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"L-Shaped Gap  Time: 0:00:01 (6 iterations)\n  Objective:       -855.8333333333358\n  Gap:             0.0\n  Number of cuts:  8\n:Optimal","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Note, that an LP capable AbstractMathProgSolver is required to solve emerging subproblems.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"LShapedSolvers uses a policy-based design. This allows combinatorially many variants of the original algorithm to be instanced by supplying linearly many policies to the factory function LShapedSolver. We briefly describe the various policies in the following.","category":"page"},{"location":"manual/structuredsolvers/#Feasibility-cuts","page":"Structured solvers","title":"Feasibility cuts","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"If the stochastic program does not have complete, or relatively complete, recourse then subproblems may be infeasible for some master iterates. Convergence can be maintained through the use of feasibility cuts. To reduce overhead and memory usage, feasibility issues are ignored by default. If you know that your problem does not have complete recourse, or if the algorithm terminates due to infeasibility, supply feasibility_cuts = true to the factory function to turn on this feature.","category":"page"},{"location":"manual/structuredsolvers/#Regularization","page":"Structured solvers","title":"Regularization","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"A Regularization procedure can improve algorithm performance. The idea is to limit the candidate search to a neighborhood of the current best iterate in the master problem. This can result in more effective cutting planes. Moreover, regularization enables warm-starting the L-shaped procedure with Crash decisions. Regularization is enabled by supplying a factory object through regularize to LShapedSolver.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The following L-shaped regularizations are available:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"NoRegularization (default)\nRegularizedDecomposition\nTrustRegion\nLevelSet","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Note, that RegularizedDecomposition and LevelSet require an AbstractMathProgSolver capable of solving QP problems. Alternatively, the 2-norm penalty term in the objective can be approximated through various linear terms. This is achieved by supplying a PenaltyTerm object through penaltyterm in either RD or LV. The alternatives are given below:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Quadratic (default)\nLinearized\nInfNorm\nManhattanNorm","category":"page"},{"location":"manual/structuredsolvers/#Aggregation","page":"Structured solvers","title":"Aggregation","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Cut aggregation can be applied to reduce communication latency and load imbalance. This can yield major performance improvements in distributed settings. Aggregation is enabled by supplying a factory object through aggregate to the factory function.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The following aggregation schemes are available:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"NoAggregation (default)\nPartialAggregation\nDynamicAggregation\nClusterAggregation\nHybridAggregation","category":"page"},{"location":"manual/structuredsolvers/#Consolidation","page":"Structured solvers","title":"Consolidation","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"If cut consolidation is enabled, cuts from previous iterations that are no longer active are aggregated to reduce the size of the master. Consolidation is enabled by supplying consolidate = Consolidate() to the factory function. See Consolidation for further details.","category":"page"},{"location":"manual/structuredsolvers/#Crash","page":"Structured solvers","title":"Crash","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The L-shaped algorithm can be crash started in various way. A good initial guess in combination with a regularization procedure can improve convergence.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The following Crash methods can be used through the crash option in the factory function.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Crash.None (default)\nCrash.EVP\nCrash.Scenario\nCrash.Custom","category":"page"},{"location":"manual/structuredsolvers/#Execution","page":"Structured solvers","title":"Execution","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"There are three available modes of execution:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Serial (default)\nSynchronous\nAsynchronous","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Running a distributed L-shaped algorithm, either synchronously or asynchronously, required adding Julia worker cores with [addprocs].","category":"page"},{"location":"manual/structuredsolvers/#References","page":"Structured solvers","title":"References","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Van Slyke, R. and Wets, R. (1969), L-Shaped Linear Programs with Applications to Optimal Control and Stochastic Programming, SIAM Journal on Applied Mathematics, vol. 17, no. 4, pp. 638-663.\nRuszczyński, A (1986), A regularized decomposition method for minimizing a sum of polyhedral functions, Mathematical Programming, vol. 35, no. 3, pp. 309-333.\nLinderoth, J. and Wright, S. (2003), Decomposition Algorithms for Stochastic Programming on a Computational Grid, Computational Optimization and Applications, vol. 24, no. 2-3, pp. 207-250.\nFábián, C. and Szőke, Z. (2006), Solving two-stage stochastic programming problems with level decomposition, Computational Management Science, vol. 4, no. 4, pp. 313-353.\nWolf, C. and Koberstein, A. (2013), Dynamic sequencing and cut con-solidation for the parallel hybrid-cut nested l-shaped method, European Journal of Operational Research, vol. 230, no. 1, pp. 143-156.\nBiel, M. and Johansson, M. (2018), Distributed L-shaped Algorithms in Julia, 2018 IEEE/ACM Parallel Applications Workshop, Alternatives To MPI (PAW-ATM).\nBiel, M. and Johansson, M. (2019), Dynamic cut aggregation in L-shaped algorithms, arXiv preprint arXiv:1910.13752.","category":"page"},{"location":"manual/structuredsolvers/#ProgressiveHedgingSolvers.jl","page":"Structured solvers","title":"ProgressiveHedgingSolvers.jl","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"StochasticPrograms also includes a collection of progressive-hedging algorithms in the submodule ProgressiveHedgingSolvers. All algorithm variants are based on the original progressive-hedging algorithm by Rockafellar and Wets. ProgressiveHedgingSolvers interfaces with StochasticPrograms through the structured solver interface. Every algorithm variant is an instance of the functor object ProgressiveHedging, and are instanced using the factory object ProgressiveHedgingSolver.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"As an example, we solve the simple problem introduced in the Quick start:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"using ProgressiveHedgingSolvers\nusing GLPKMathProgInterface\n\noptimize!(sp, solver = ProgressiveHedgingSolver(GLPKSolverLP, penaltyterm = Linearized(nbreakpoints=30))","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Progressive Hedging Time: 0:00:00 (91 iterations)\n  Objective:  -855.8017375415484\n  δ:          9.700002687897287e-6\n:Optimal","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Note, that an QP/LP capable AbstractMathProgSolver is required to solve emerging subproblems.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"ProgressiveHedgingSolvers also uses a policy-based design. See ProgressiveHedgingSolver for options. We briefly describe the various policies in the following.","category":"page"},{"location":"manual/structuredsolvers/#Penalty","page":"Structured solvers","title":"Penalty","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"There are two options for the penalty parameter used in the progressive-hedging algorithm. The alternatives are","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Fixed (default)\nAdaptive","category":"page"},{"location":"manual/structuredsolvers/#Execution-2","page":"Structured solvers","title":"Execution","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The same execution policies as for LShapedSolvers are available in ProgressiveHedgingSolvers, i.e.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Serial (default)\nSynchronous\nAsynchronous","category":"page"},{"location":"manual/structuredsolvers/#Penalty-term","page":"Structured solvers","title":"Penalty term","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"As with the L-shaped variants with quadratic 2-norm terms, the 2-norm term in progressive-hedging subproblems can be approximated. This enables the use of AbstractMathProgSolver that only solve linear problems. The alternatives are as before:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Quadratic (default)\nLinearized\nInfNorm\nManhattanNorm","category":"page"},{"location":"manual/structuredsolvers/#References-2","page":"Structured solvers","title":"References","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"R. T. Rockafellar and Roger J.-B. Wets (1991), Scenarios and Policy Aggregation in Optimization Under Uncertainty, Mathematics of Operations Research, vol. 16, no. 1, pp. 119-147.\nZehtabian. S and Bastin. F (2016), Penalty parameter update strategies in progressive hedging algorithm","category":"page"}]
}
