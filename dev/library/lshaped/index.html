<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>L-shaped solvers · StochasticPrograms.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">StochasticPrograms.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/quickstart/">Quick start</a></li><li><a class="tocitem" href="../../manual/data/">Stochastic data</a></li><li><a class="tocitem" href="../../manual/model/">Stochastic models</a></li><li><a class="tocitem" href="../../manual/distributed/">Distributed stochastic programs</a></li><li><a class="tocitem" href="../../manual/structuredsolvers/">Structured solvers</a></li><li><a class="tocitem" href="../../manual/examples/">Examples</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../public/">Public interface</a></li><li><a class="tocitem" href="../solverinterface/">Solver interface</a></li><li><a class="tocitem" href="../crash/">Crash</a></li><li class="is-active"><a class="tocitem" href>L-shaped solvers</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#L-shaped-solver-factory"><span>L-shaped solver factory</span></a></li><li><a class="tocitem" href="#Execution"><span>Execution</span></a></li><li><a class="tocitem" href="#Regularization"><span>Regularization</span></a></li><li><a class="tocitem" href="#Aggregation"><span>Aggregation</span></a></li><li><a class="tocitem" href="#Consolidation"><span>Consolidation</span></a></li></ul></li><li><a class="tocitem" href="../progressivehedging/">Progressive-hedging solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>L-shaped solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>L-shaped solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/master/docs/src/library/lshaped.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="L-shaped-solvers"><a class="docs-heading-anchor" href="#L-shaped-solvers">L-shaped solvers</a><a id="L-shaped-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#L-shaped-solvers" title="Permalink"></a></h1><p>Documentation for <code>StochasticPrograms.jl</code>&#39;s L-shaped solvers.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#StochasticPrograms.LShapedSolvers.Aggregate"><code>StochasticPrograms.LShapedSolvers.Aggregate</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.AsynchronousExecution"><code>StochasticPrograms.LShapedSolvers.AsynchronousExecution</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.ClusterAggregate"><code>StochasticPrograms.LShapedSolvers.ClusterAggregate</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.ClusterAggregation"><code>StochasticPrograms.LShapedSolvers.ClusterAggregation</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.ClusterByReference-Tuple{AbstractFloat}"><code>StochasticPrograms.LShapedSolvers.ClusterByReference</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.Consolidate"><code>StochasticPrograms.LShapedSolvers.Consolidate</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.Consolidation"><code>StochasticPrograms.LShapedSolvers.Consolidation</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.DontAggregate"><code>StochasticPrograms.LShapedSolvers.DontAggregate</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.DontConsolidate"><code>StochasticPrograms.LShapedSolvers.DontConsolidate</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.DontRegularize"><code>StochasticPrograms.LShapedSolvers.DontRegularize</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.DynamicAggregate"><code>StochasticPrograms.LShapedSolvers.DynamicAggregate</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.DynamicAggregation"><code>StochasticPrograms.LShapedSolvers.DynamicAggregation</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.Hierarchical"><code>StochasticPrograms.LShapedSolvers.Hierarchical</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.HybridAggregate"><code>StochasticPrograms.LShapedSolvers.HybridAggregate</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.HybridAggregation"><code>StochasticPrograms.LShapedSolvers.HybridAggregation</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.Kmedoids"><code>StochasticPrograms.LShapedSolvers.Kmedoids</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.LShaped"><code>StochasticPrograms.LShapedSolvers.LShaped</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.LShapedSolver"><code>StochasticPrograms.LShapedSolvers.LShapedSolver</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.LV"><code>StochasticPrograms.LShapedSolvers.LV</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.LevelSet"><code>StochasticPrograms.LShapedSolvers.LevelSet</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.NoAggregation"><code>StochasticPrograms.LShapedSolvers.NoAggregation</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.NoConsolidation"><code>StochasticPrograms.LShapedSolvers.NoConsolidation</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.NoRegularization"><code>StochasticPrograms.LShapedSolvers.NoRegularization</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.PartialAggregate"><code>StochasticPrograms.LShapedSolvers.PartialAggregate</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.PartialAggregation"><code>StochasticPrograms.LShapedSolvers.PartialAggregation</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.RD"><code>StochasticPrograms.LShapedSolvers.RD</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.RegularizedDecomposition"><code>StochasticPrograms.LShapedSolvers.RegularizedDecomposition</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.SelectClosest"><code>StochasticPrograms.LShapedSolvers.SelectClosest</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.SelectClosestToReference"><code>StochasticPrograms.LShapedSolvers.SelectClosestToReference</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.SelectDecaying"><code>StochasticPrograms.LShapedSolvers.SelectDecaying</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.SelectRandom"><code>StochasticPrograms.LShapedSolvers.SelectRandom</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.SelectUniform"><code>StochasticPrograms.LShapedSolvers.SelectUniform</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.SerialExecution"><code>StochasticPrograms.LShapedSolvers.SerialExecution</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.StaticCluster"><code>StochasticPrograms.LShapedSolvers.StaticCluster</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.SynchronousExecution"><code>StochasticPrograms.LShapedSolvers.SynchronousExecution</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.TR"><code>StochasticPrograms.LShapedSolvers.TR</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.TrustRegion"><code>StochasticPrograms.LShapedSolvers.TrustRegion</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.FullAggregation-Union{Tuple{T}, Tuple{Integer,Integer,Type{T}}} where T&lt;:AbstractFloat"><code>StochasticPrograms.LShapedSolvers.FullAggregation</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.absolute_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>StochasticPrograms.LShapedSolvers.absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.angular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>StochasticPrograms.LShapedSolvers.angular_distance</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.at_tolerance-Tuple{}"><code>StochasticPrograms.LShapedSolvers.at_tolerance</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.spatioangular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>StochasticPrograms.LShapedSolvers.spatioangular_distance</code></a></li></ul><h2 id="L-shaped-solver-factory"><a class="docs-heading-anchor" href="#L-shaped-solver-factory">L-shaped solver factory</a><a id="L-shaped-solver-factory-1"></a><a class="docs-heading-anchor-permalink" href="#L-shaped-solver-factory" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.LShapedSolver" href="#StochasticPrograms.LShapedSolvers.LShapedSolver"><code>StochasticPrograms.LShapedSolvers.LShapedSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LShapedSolver(lpsolver::AbstractMathProgSolver; &lt;keyword arguments&gt;)</code></pre><p>Return an L-shaped algorithm object that can optimize a two-stage <code>StochasticPrograms</code>. Supply <code>lpsolver</code>, a MathProgBase solver capable of solving linear-quadratic problems.</p><p>The following L-shaped regularizations are available</p><ul><li><a href="#StochasticPrograms.LShapedSolvers.NoRegularization"><code>NoRegularization</code></a>:  L-shaped algorithm (default)</li><li><a href="#StochasticPrograms.LShapedSolvers.RegularizedDecomposition"><code>RegularizedDecomposition</code></a>:  Regularized decomposition ?RegularizedDecomposition for parameter descriptions.</li><li><a href="#StochasticPrograms.LShapedSolvers.TrustRegion"><code>TrustRegion</code></a>:  Trust-region ?TrustRegion for parameter descriptions.</li><li><a href="#StochasticPrograms.LShapedSolvers.LevelSet"><code>LevelSet</code></a>:  Level-set ?LevelSet for parameter descriptions.</li></ul><p>The following aggregation schemes are available</p><ul><li><a href="#StochasticPrograms.LShapedSolvers.NoAggregation"><code>NoAggregation</code></a>:  Multi-cut L-shaped algorithm (default)</li><li><a href="#StochasticPrograms.LShapedSolvers.PartialAggregation"><code>PartialAggregation</code></a>:  ?PartialAggregation for parameter descriptions.</li><li><a href="#StochasticPrograms.LShapedSolvers.FullAggregation-Union{Tuple{T}, Tuple{Integer,Integer,Type{T}}} where T&lt;:AbstractFloat"><code>FullAggregation</code></a>:  ?FullAggregation for parameter descriptions.</li><li><a href="#StochasticPrograms.LShapedSolvers.DynamicAggregation"><code>DynamicAggregation</code></a>:  ?DynamicAggregation for parameter descriptions.</li><li><a href="#StochasticPrograms.LShapedSolvers.ClusterAggregation"><code>ClusterAggregation</code></a>:  ?ClusterAggregation for parameter descriptions.</li><li><a href="#StochasticPrograms.LShapedSolvers.HybridAggregation"><code>HybridAggregation</code></a>:  ?HybridAggregation for parameter descriptions.</li></ul><p>The following consolidation schemes are available</p><ul><li><a href="#StochasticPrograms.LShapedSolvers.NoConsolidation"><code>NoConsolidation</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.Consolidation"><code>Consolidation</code></a></li></ul><p>The following execution policies are available</p><ul><li><a href="../solverinterface/#StochasticPrograms.Serial"><code>Serial</code></a>:  Classical L-shaped (default)</li><li><a href="../solverinterface/#StochasticPrograms.Synchronous"><code>Synchronous</code></a>: Classical L-shaped run in parallel</li><li><a href="../solverinterface/#StochasticPrograms.Asynchronous"><code>Asynchronous</code></a>: Asynchronous L-shaped ?Asynchronous for parameter descriptions.</li></ul><p>...</p><p><strong>Arguments</strong></p><ul><li><code>lpsolver::AbstractMathProgSolver</code>: MathProgBase solver capable of solving linear (and possibly quadratic) programs.</li><li><code>feasibility_cuts::Bool = false</code>: Specify if feasibility cuts should be used</li><li><code>subsolver::AbstractMathProgSolver = lpsolver</code>: Optionally specify a different solver for the subproblems.</li><li><code>regularize::AbstractRegularizer = DontRegularize()</code>: Specify regularization procedure (DontRegularize, RegularizedDecomposition/RD/WithRegularizedDecomposition, TrustRegion/TR/WithTrustRegion, LevelSet/LV/WithLevelSets).</li><li><code>aggregate::AbstractAggregator = DontAggregate()</code>: Specify aggregation procedure (DontAggregate, Aggregate, PartialAggregate, DynamicAggregate)</li><li><code>consolidate::AbstractConsolidator = DontConsolidate()</code>: Specify consolidation procedure (DontConsolidate, Consolidate)</li><li><code>execution::Execution = Serial</code>: Specify how algorithm should be executed (Serial, Synchronous, Asynchronous). Distributed variants requires worker cores.</li><li><code>crash::CrashMethod = Crash.None</code>: Crash method used to generate an initial decision. See ?Crash for alternatives.</li><li>&lt;keyword arguments&gt;: Algorithm specific parameters, See <code>?LShaped</code> for list of possible arguments and default values.</li></ul><p>...</p><p><strong>Examples</strong></p><p>The following solves a stochastic program <code>sp</code> created in <code>StochasticPrograms.jl</code> using the L-shaped algorithm with GLPK as an <code>lpsolver</code>.</p><pre><code class="language-julia-repl">julia&gt; optimize!(sp, solver = LShapedSolver(GLPKSolverLP()))
L-Shaped Gap  Time: 0:00:00 (6 iterations)
  Objective:       -855.8333333333339
  Gap:             0.0
  Number of cuts:  8
  Iterations:      6
:Optimal</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/spinterface.jl#L1-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.LShaped" href="#StochasticPrograms.LShapedSolvers.LShaped"><code>StochasticPrograms.LShapedSolvers.LShaped</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LShaped</code></pre><p>Functor object for the L-shaped algorithm. Create using the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>...</p><p><strong>Algorithm parameters</strong></p><ul><li><code>τ::AbstractFloat = 1e-6</code>: Relative tolerance for convergence checks.</li><li><code>debug::Bool = false</code>: Specifies if extra information should be saved for debugging purposes. Defaults to false for memory efficiency.</li><li><code>cut_scaling::AbstractFloat = 1.0</code>: Rescaling factor for cutting planes to improve numerical stability.</li><li><code>log::Bool = true</code>: Specifices if L-shaped procedure should be logged on standard output or not.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/solver.jl#L19-L31">source</a></section></article><h2 id="Execution"><a class="docs-heading-anchor" href="#Execution">Execution</a><a id="Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Execution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.SerialExecution" href="#StochasticPrograms.LShapedSolvers.SerialExecution"><code>StochasticPrograms.LShapedSolvers.SerialExecution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SerialExecution</code></pre><p>Functor object for using serial execution in a lshaped algorithm. Create by supplying a <a href="../solverinterface/#StochasticPrograms.Serial"><code>Serial</code></a> object through <code>execution</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/execution/serial.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.SynchronousExecution" href="#StochasticPrograms.LShapedSolvers.SynchronousExecution"><code>StochasticPrograms.LShapedSolvers.SynchronousExecution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SynchronousExecution</code></pre><p>Functor object for using synchronous execution in an L-shaped algorithm (assuming multiple Julia cores are available). Create by supplying a <a href="../solverinterface/#StochasticPrograms.Synchronous"><code>Synchronous</code></a> object through <code>execution</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/execution/synchronous.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.AsynchronousExecution" href="#StochasticPrograms.LShapedSolvers.AsynchronousExecution"><code>StochasticPrograms.LShapedSolvers.AsynchronousExecution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AsynchronousExecution</code></pre><p>Functor object for using synchronous execution in an L-shaped algorithm (assuming multiple Julia cores are available). Create by supplying a <a href="../solverinterface/#StochasticPrograms.Asynchronous"><code>Asynchronous</code></a> object through <code>execution</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/execution/asynchronous.jl#L7-L12">source</a></section></article><h2 id="Regularization"><a class="docs-heading-anchor" href="#Regularization">Regularization</a><a id="Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Regularization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.NoRegularization" href="#StochasticPrograms.LShapedSolvers.NoRegularization"><code>StochasticPrograms.LShapedSolvers.NoRegularization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoRegularization</code></pre><p>Empty functor object for running an L-shaped algorithm without regularization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/regularizers/no_regularization.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.DontRegularize" href="#StochasticPrograms.LShapedSolvers.DontRegularize"><code>StochasticPrograms.LShapedSolvers.DontRegularize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DontRegularize</code></pre><p>Factory object for <a href="#StochasticPrograms.LShapedSolvers.NoRegularization"><code>NoRegularization</code></a>. Passed by default to <code>regularize</code> in the <code>LShapedSolver</code> factory function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/regularizers/no_regularization.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.RegularizedDecomposition" href="#StochasticPrograms.LShapedSolvers.RegularizedDecomposition"><code>StochasticPrograms.LShapedSolvers.RegularizedDecomposition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularizedDecomposition</code></pre><p>Functor object for using regularized decomposition regularization in an L-shaped algorithm. Create by supplying an <a href="#StochasticPrograms.LShapedSolvers.RD"><code>RD</code></a> object through <code>regularize</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>σ::AbstractFloat = 1.0</code>: Initial value of regularization parameter. Controls the relative penalty of the deviation from the current major iterate.</li><li><code>σ̅::AbstractFloat = 4.0</code>: Maximum value of the regularization parameter.</li><li><code>σ̲::AbstractFloat = 0.5</code>: Minimum value of the regularization parameter.</li><li><code>log::Bool = true</code>: Specifices if L-shaped procedure should be logged on standard output or not.</li><li><code>penaltyterm::PenaltyTerm = Quadratic</code>: Specify penaltyterm variant (<a href="../solverinterface/#StochasticPrograms.Quadratic"><code>Quadratic</code></a>, <a href="../solverinterface/#StochasticPrograms.Linearized"><code>Linearized</code></a>, <a href="../solverinterface/#StochasticPrograms.InfNorm"><code>InfNorm</code></a>, [<code>ManhattanNorm</code>][@ref])</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/regularizers/rd.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.RD" href="#StochasticPrograms.LShapedSolvers.RD"><code>StochasticPrograms.LShapedSolvers.RD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RD</code></pre><p>Factory object for <a href="#StochasticPrograms.LShapedSolvers.RegularizedDecomposition"><code>RegularizedDecomposition</code></a>. Pass to <code>regularize</code> in the <code>LShapedSolver</code> factory function. Equivalent factory calls: <code>RD</code>, <code>WithRD</code>, <code>RegularizedDecomposition</code>, <code>WithRegularizedDecomposition</code>. See ?RegularizedDecomposition for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/regularizers/rd.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.TrustRegion" href="#StochasticPrograms.LShapedSolvers.TrustRegion"><code>StochasticPrograms.LShapedSolvers.TrustRegion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TrustRegion</code></pre><p>Functor object for using trust-region regularization in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShapedSolvers.TR"><code>TR</code></a> object through <code>regularize</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>γ::T = 1e-4</code>: Relative tolerance for deciding if a minor iterate should be accepted as a new major iterate.</li><li><code>Δ::AbstractFloat = 1.0</code>: Initial size of ∞-norm trust-region.</li><li><code>Δ̅::AbstractFloat = 1000.0</code>: Maximum size of ∞-norm trust-region.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/regularizers/tr.jl#L18-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.TR" href="#StochasticPrograms.LShapedSolvers.TR"><code>StochasticPrograms.LShapedSolvers.TR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TR</code></pre><p>Factory object for <a href="#StochasticPrograms.LShapedSolvers.TrustRegion"><code>TrustRegion</code></a>. Pass to <code>regularize</code> in the <code>LShapedSolver</code> factory function. Equivalent factory calls: <code>TR</code>, <code>WithTR</code>, <code>TrustRegion</code>, <code>WithTrustRegion</code>. See ?TrustRegion for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/regularizers/tr.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.LevelSet" href="#StochasticPrograms.LShapedSolvers.LevelSet"><code>StochasticPrograms.LShapedSolvers.LevelSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LevelSet</code></pre><p>Functor object for using level-set regularization in an L-shaped algorithm. Create by supplying an <a href="#StochasticPrograms.LShapedSolvers.LV"><code>LV</code></a> object through <code>regularize</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>λ::AbstractFloat = 0.5</code>: Controls the level position L = (1-λ)<em>θ + λ</em>Q̃, a convex combination of the current lower and upper bound.</li><li><code>penaltyterm::PenaltyTerm = Quadratic</code>: Specify penaltyterm variant (<a href="../solverinterface/#StochasticPrograms.Quadratic"><code>Quadratic</code></a>, <a href="../solverinterface/#StochasticPrograms.Linearized"><code>Linearized</code></a>, <a href="../solverinterface/#StochasticPrograms.InfNorm"><code>InfNorm</code></a>, [<code>ManhattanNorm</code>][@ref])</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/regularizers/lv.jl#L15-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.LV" href="#StochasticPrograms.LShapedSolvers.LV"><code>StochasticPrograms.LShapedSolvers.LV</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LV</code></pre><p>Factory object for <a href="#StochasticPrograms.LShapedSolvers.LevelSet"><code>LevelSet</code></a>. Pass to <code>regularize</code> in the <code>LShapedSolver</code> factory function. Equivalent factory calls: <code>LV</code>, <code>WithLV</code>, <code>LevelSet</code>, <code>WithLevelSets</code>. See ?LevelSet for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/regularizers/lv.jl#L144-L149">source</a></section></article><h2 id="Aggregation"><a class="docs-heading-anchor" href="#Aggregation">Aggregation</a><a id="Aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.DontAggregate" href="#StochasticPrograms.LShapedSolvers.DontAggregate"><code>StochasticPrograms.LShapedSolvers.DontAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DontAggregate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShapedSolvers.NoAggregation"><code>NoAggregation</code></a>. Passed by default to <code>aggregate</code> in the <code>LShapedSolver</code> factory function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/no_aggregation.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.NoAggregation" href="#StochasticPrograms.LShapedSolvers.NoAggregation"><code>StochasticPrograms.LShapedSolvers.NoAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoAggregation</code></pre><p>Empty functor object for running an L-shaped algorithm without aggregation (multi-cut L-shaped).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/no_aggregation.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.Aggregate" href="#StochasticPrograms.LShapedSolvers.Aggregate"><code>StochasticPrograms.LShapedSolvers.Aggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Aggregate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShapedSolvers.FullAggregation-Union{Tuple{T}, Tuple{Integer,Integer,Type{T}}} where T&lt;:AbstractFloat"><code>FullAggregation</code></a>. Pass to <code>aggregate</code> in the <code>LShapedSolver</code> factory function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/partial_aggregation.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.PartialAggregate" href="#StochasticPrograms.LShapedSolvers.PartialAggregate"><code>StochasticPrograms.LShapedSolvers.PartialAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PartialAggregate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShapedSolvers.PartialAggregation"><code>PartialAggregation</code></a>. Pass to <code>aggregate</code> in the <code>LShapedSolver</code> factory function.  See ?PartialAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/partial_aggregation.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.PartialAggregation" href="#StochasticPrograms.LShapedSolvers.PartialAggregation"><code>StochasticPrograms.LShapedSolvers.PartialAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PartialAggregation</code></pre><p>Functor object for using partial aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShapedSolvers.PartialAggregate"><code>PartialAggregate</code></a> object through <code>aggregate</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>size::Int</code>: Number of cuts in each aggregate</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/partial_aggregation.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.FullAggregation-Union{Tuple{T}, Tuple{Integer,Integer,Type{T}}} where T&lt;:AbstractFloat" href="#StochasticPrograms.LShapedSolvers.FullAggregation-Union{Tuple{T}, Tuple{Integer,Integer,Type{T}}} where T&lt;:AbstractFloat"><code>StochasticPrograms.LShapedSolvers.FullAggregation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FullAggregation</code></pre><p>Functor object for using complete aggregation in an L-shaped algorithm. Create by supplying an <a href="#StochasticPrograms.LShapedSolvers.Aggregate"><code>Aggregate</code></a> object through <code>aggregate</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/partial_aggregation.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.DynamicAggregate" href="#StochasticPrograms.LShapedSolvers.DynamicAggregate"><code>StochasticPrograms.LShapedSolvers.DynamicAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DynamicAggregate(naggregates::Integer, rule::SelectionRule; lock_after::Function = (τ,n)-&gt;false)</code></pre><p>Factory object for <a href="#StochasticPrograms.LShapedSolvers.DynamicAggregation"><code>DynamicAggregation</code></a>. Pass to <code>aggregate</code> in the <code>LShapedSolver</code> factory function. See ?DynamicAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/dynamic_aggregation.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.DynamicAggregation" href="#StochasticPrograms.LShapedSolvers.DynamicAggregation"><code>StochasticPrograms.LShapedSolvers.DynamicAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DynamicAggregation</code></pre><p>Functor object for using dynamic aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShapedSolvers.DynamicAggregate"><code>DynamicAggregate</code></a> object through <code>aggregate</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>The following selection rules are available</p><ul><li><a href="#StochasticPrograms.LShapedSolvers.SelectUniform"><code>SelectUniform</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.SelectDecaying"><code>SelectDecaying</code></a></li><li>[<code>SelectRandom</code>](@ref</li><li><a href="#StochasticPrograms.LShapedSolvers.SelectClosest"><code>SelectClosest</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.SelectClosestToReference"><code>SelectClosestToReference</code></a></li></ul><p>...</p><p><strong>Parameters</strong></p><ul><li><code>naggregates::Int</code>: Number of aggregates</li><li><code>rule::SelectionRule</code>: Rule that determines which aggregate an incoming cut should be placed in</li><li><code>lock_after::Function = (τ,n)-&gt;false</code>: Function that determines if the current aggregation scheme should be fixed, based on the current optimality gap <code>τ</code> and the number of iterations <code>n</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/dynamic_aggregation.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.ClusterAggregate" href="#StochasticPrograms.LShapedSolvers.ClusterAggregate"><code>StochasticPrograms.LShapedSolvers.ClusterAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ClusterAggregate(rule::ClusterRule; lock_after::Function = (τ,n)-&gt;false)</code></pre><p>Factory object for <a href="#StochasticPrograms.LShapedSolvers.ClusterAggregation"><code>ClusterAggregation</code></a>. Pass to <code>aggregate</code> in the <code>LShapedSolver</code> factory function. See ?ClusterAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/cluster_aggregation.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.ClusterAggregation" href="#StochasticPrograms.LShapedSolvers.ClusterAggregation"><code>StochasticPrograms.LShapedSolvers.ClusterAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ClusterAggregation</code></pre><p>Functor object for using cluster aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShapedSolvers.ClusterAggregate"><code>ClusterAggregate</code></a> object through <code>aggregate</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>The following cluster rules are available</p><ul><li><a href="#StochasticPrograms.LShapedSolvers.StaticCluster"><code>StaticCluster</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.ClusterByReference-Tuple{AbstractFloat}"><code>ClusterByReference</code></a></li><li>[<code>Kmedoids</code>](@ref</li><li><a href="#StochasticPrograms.LShapedSolvers.Hierarchical"><code>Hierarchical</code></a></li></ul><p>...</p><p><strong>Parameters</strong></p><ul><li><code>rule::ClusterRule</code>: Rule that determines how cuts should be sorted into clusters</li><li><code>lock_after::Function = (τ,n)-&gt;false</code>: Function that determines if the current aggregation scheme should be fixed, based on the current optimality gap <code>τ</code> and the number of iterations <code>n</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/cluster_aggregation.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.HybridAggregate" href="#StochasticPrograms.LShapedSolvers.HybridAggregate"><code>StochasticPrograms.LShapedSolvers.HybridAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HybridAggregate(initial::AbstractAggregator, final::AbstractAggregator, τ::AbstractFloat)</code></pre><p>Factory object for <a href="#StochasticPrograms.LShapedSolvers.HybridAggregation"><code>HybridAggregation</code></a>. Pass to <code>aggregate</code> in the <code>LShapedSolver</code> factory function. See ?HybridAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/hybrid_aggregation.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.HybridAggregation" href="#StochasticPrograms.LShapedSolvers.HybridAggregation"><code>StochasticPrograms.LShapedSolvers.HybridAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HybridAggregation</code></pre><p>Functor object for using hybrid aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShapedSolvers.HybridAggregate"><code>HybridAggregate</code></a> object through <code>aggregate</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>initial::AbstractAggregator</code>: Initial aggregation scheme</li><li><code>final::AbstractAggregator</code>: Final aggregation scheme</li><li><code>τ::T</code>: The active aggregation scheme is switched from <code>initial</code> to <code>final</code> when the optimality gap decreases below <code>τ</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/hybrid_aggregation.jl#L15-L26">source</a></section></article><h3 id="Selection-rules"><a class="docs-heading-anchor" href="#Selection-rules">Selection rules</a><a id="Selection-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Selection-rules" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.SelectClosest" href="#StochasticPrograms.LShapedSolvers.SelectClosest"><code>StochasticPrograms.LShapedSolvers.SelectClosest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SelectClosest(τ::AbstractFloat; distance::Function = absolute_distance)</code></pre><p>Incoming cuts are placed into the closest aggregate, according the supplied <code>distance</code> function. An empty aggregate is chosen if no aggregate is within the tolerance <code>τ</code></p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShapedSolvers.absolute_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.angular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L97-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.SelectClosestToReference" href="#StochasticPrograms.LShapedSolvers.SelectClosestToReference"><code>StochasticPrograms.LShapedSolvers.SelectClosestToReference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SelectClosestToReference(τ::AbstractFloat; distance::Function = absolute_distance)</code></pre><p>Incoming cuts are placed into an aggregate based on the distance to a reference cut, according the supplied <code>distance</code> function. Behaves as <a href="#StochasticPrograms.LShapedSolvers.SelectClosest"><code>SelectClosest</code></a> if not withing the tolerance <code>τ</code> to the reference cut.</p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShapedSolvers.absolute_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.angular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L134-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.SelectDecaying" href="#StochasticPrograms.LShapedSolvers.SelectDecaying"><code>StochasticPrograms.LShapedSolvers.SelectDecaying</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SelectDecaying(T₀::Integer, T̲::Integer = 1, γ::T)</code></pre><p>Behaves like <a href="#StochasticPrograms.LShapedSolvers.SelectUniform"><code>SelectUniform</code></a>, but the uniform aggregate size decays by <code>γ</code> each iteration, starting from <code>T₀</code>. <code>T̲</code> is an optional lower bound on the aggregate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.SelectRandom" href="#StochasticPrograms.LShapedSolvers.SelectRandom"><code>StochasticPrograms.LShapedSolvers.SelectRandom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SelectRandom(max = Inf)</code></pre><p>Incoming cuts are placed into aggregates randomly. An optional maximum number of cuts <code>max</code> can be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.SelectUniform" href="#StochasticPrograms.LShapedSolvers.SelectUniform"><code>StochasticPrograms.LShapedSolvers.SelectUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SelectUniform(n::Integer)</code></pre><p>Incoming cuts are placed into aggregates uniformly, so that each aggregate has at most <code>n</code> cuts. Behaves as <a href="#StochasticPrograms.LShapedSolvers.PartialAggregation"><code>PartialAggregation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L7-L12">source</a></section></article><h3 id="Cluster-rules"><a class="docs-heading-anchor" href="#Cluster-rules">Cluster rules</a><a id="Cluster-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-rules" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.ClusterByReference-Tuple{AbstractFloat}" href="#StochasticPrograms.LShapedSolvers.ClusterByReference-Tuple{AbstractFloat}"><code>StochasticPrograms.LShapedSolvers.ClusterByReference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ClusterByReference(τ::AbstractFloat; distance::Function = absolute_distance)</code></pre><p>Buffered cuts are aggregated if within the tolerance <code>τ</code> to a reference cut, according the supplied <code>distance</code> function. Behaves as multi-cut otherwise.</p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShapedSolvers.absolute_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.angular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/cluster_rules.jl#L46-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.Hierarchical" href="#StochasticPrograms.LShapedSolvers.Hierarchical"><code>StochasticPrograms.LShapedSolvers.Hierarchical</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Hierarchical(nclusters::Int; distance::Function = absolute_distance, linkage::Symbol = :single)</code></pre><p>Buffered cuts are sorted into <code>nclusters</code> clusters, using a Hierarchical algorithm, with the given <code>linkage</code>, over a generalized <code>distance</code> matrix.</p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShapedSolvers.absolute_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.angular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/cluster_rules.jl#L140-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.Kmedoids" href="#StochasticPrograms.LShapedSolvers.Kmedoids"><code>StochasticPrograms.LShapedSolvers.Kmedoids</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Kmedoids(nclusters::Int; distance::Function = absolute_distance)</code></pre><p>Buffered cuts are sorted into <code>nclusters</code> clusters, using a K-medoids algorithm over a generalized <code>distance</code> matrix.</p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShapedSolvers.absolute_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShapedSolvers.angular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/cluster_rules.jl#L86-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.StaticCluster" href="#StochasticPrograms.LShapedSolvers.StaticCluster"><code>StochasticPrograms.LShapedSolvers.StaticCluster</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StaticCluster(clusters::Vector{Float64})</code></pre><p>Buffered cuts are sorting according to the supplied weights <code>clusters</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/cluster_rules.jl#L3-L8">source</a></section></article><h3 id="Distance-measures"><a class="docs-heading-anchor" href="#Distance-measures">Distance measures</a><a id="Distance-measures-1"></a><a class="docs-heading-anchor-permalink" href="#Distance-measures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.absolute_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}" href="#StochasticPrograms.LShapedSolvers.absolute_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>StochasticPrograms.LShapedSolvers.absolute_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">absolute_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)</code></pre><p>Absolute distance between two optimality cuts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/distance_measures.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.angular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}" href="#StochasticPrograms.LShapedSolvers.angular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>StochasticPrograms.LShapedSolvers.angular_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angular_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)</code></pre><p>Angular distance between two optimality cuts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/distance_measures.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.spatioangular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}" href="#StochasticPrograms.LShapedSolvers.spatioangular_distance-Tuple{Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T,Union{AggregatedOptimalityCut{T,A}, HyperPlane{OptimalityCut,T,A}} where A where T}"><code>StochasticPrograms.LShapedSolvers.spatioangular_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spatioangular_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)</code></pre><p>Spatioangular distance between two optimality cuts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/aggregators/distance_measures.jl#L35-L40">source</a></section></article><h2 id="Consolidation"><a class="docs-heading-anchor" href="#Consolidation">Consolidation</a><a id="Consolidation-1"></a><a class="docs-heading-anchor-permalink" href="#Consolidation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.Consolidate" href="#StochasticPrograms.LShapedSolvers.Consolidate"><code>StochasticPrograms.LShapedSolvers.Consolidate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Consolidate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShapedSolvers.Consolidation"><code>Consolidation</code></a>. Pass to <code>consolidate</code> in the <code>LShapedSolver</code> factory function. See ?Consolidation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/consolidators/consolidation.jl#L184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.Consolidation" href="#StochasticPrograms.LShapedSolvers.Consolidation"><code>StochasticPrograms.LShapedSolvers.Consolidation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Consolidation</code></pre><p>Functor object for using consolidation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShapedSolvers.Consolidate"><code>Consolidate</code></a> object through <code>consolidate</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>...</p><p><strong>Algorithm parameters</strong></p><ul><li><code>tresh::T</code> = 0.95: Relative amount of redundant cuts in a former iteration required to consider the iteration redundant</li><li><code>at::Int = 5.0</code>: Number of times an iteration can be redundant before consolidation is triggered</li><li><code>rebuild::Function = at_tolerance()</code>: Function deciding when the master model should be rebuilt according to performed consolidations</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/consolidators/consolidation.jl#L27-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.DontConsolidate" href="#StochasticPrograms.LShapedSolvers.DontConsolidate"><code>StochasticPrograms.LShapedSolvers.DontConsolidate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DontConsolidate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShapedSolvers.NoConsolidation"><code>NoConsolidation</code></a>. Passed by default to <code>consolidate</code> in the <code>LShapedSolver</code> factory function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/consolidators/consolidation.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.NoConsolidation" href="#StochasticPrograms.LShapedSolvers.NoConsolidation"><code>StochasticPrograms.LShapedSolvers.NoConsolidation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoRegularization</code></pre><p>Empty functor object for running the L-shaped algorithm without consolidation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/consolidators/consolidation.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShapedSolvers.at_tolerance-Tuple{}" href="#StochasticPrograms.LShapedSolvers.at_tolerance-Tuple{}"><code>StochasticPrograms.LShapedSolvers.at_tolerance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">at_tolerance(τ = 0.4, miniter = 0)</code></pre><p>Rebuild master when at least nconsolidations*<code>miniter</code> iterations has passed and the ratio of number of cuts in the consolidated collection and the number of cuts in the master model has decreased below <code>τ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/8789e362eaa212eb160e103998c4e831c5fdb65b/src/solvers/structured/lshaped/consolidators/consolidation.jl#L157-L162">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../crash/">« Crash</a><a class="docs-footer-nextpage" href="../progressivehedging/">Progressive-hedging solvers »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 14 July 2020 09:32">Tuesday 14 July 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
