<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Structured solvers · StochasticPrograms.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">StochasticPrograms.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickstart/">Quick start</a></li><li><a class="tocitem" href="../data/">Stochastic data</a></li><li><a class="tocitem" href="../model/">Stochastic models</a></li><li><a class="tocitem" href="../distributed/">Distributed stochastic programs</a></li><li class="is-active"><a class="tocitem" href>Structured solvers</a><ul class="internal"><li><a class="tocitem" href="#Solver-interface"><span>Solver interface</span></a></li><li><a class="tocitem" href="#L-shaped-solvers"><span>L-shaped solvers</span></a></li><li><a class="tocitem" href="#ProgressiveHedgingSolvers.jl"><span>ProgressiveHedgingSolvers.jl</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../library/public/">Public interface</a></li><li><a class="tocitem" href="../../library/solverinterface/">Solver interface</a></li><li><a class="tocitem" href="../../library/crash/">Crash</a></li><li><a class="tocitem" href="../../library/lshaped/">L-shaped solvers</a></li><li><a class="tocitem" href="../../library/progressivehedging/">Progressive-hedging solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Structured solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Structured solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/master/docs/src/manual/structuredsolvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Structured-solvers"><a class="docs-heading-anchor" href="#Structured-solvers">Structured solvers</a><a id="Structured-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Structured-solvers" title="Permalink"></a></h1><p>A stochastic program has a structure that can be exploited in solver algorithms through decomposition. This can heavily reduce the computation time required to optimize the stochastic program, compared to solving the extensive form directly. Moreover, a distributed stochastic program is by definition decomposed and a structured solver that can operate in parallel will be much more efficient.</p><h2 id="Solver-interface"><a class="docs-heading-anchor" href="#Solver-interface">Solver interface</a><a id="Solver-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-interface" title="Permalink"></a></h2><p>The structured solver interface mimics that of <code>MathProgBase</code>, and it needs to be implemented by any structured solver to be compatible with StochasticPrograms. We distinguish between structure-exploiting solvers for solving finite stochastic programs and sampled-bases solvers for approximately solving stochastic models, even though they can be based on the same algorithm.</p><p>Some procedures in StochasticPrograms require a <code>MathProgBase</code> solver. It is common that structured solvers rely internally on some <code>MathProgBase</code> solver. Hence, for convenience, a solver can implement <a href="../../library/solverinterface/#StochasticPrograms.internal_solver-Tuple{AbstractSampledSolver}"><code>internal_solver</code></a> to return any internal <code>MathProgBase</code> solver. A stochastic program that has an loaded structured solver that implements this method can then make use of that solver for those procedures, instead of requiring an external solver to be supplied. Finally, a structured solver can optionally implement <a href="../../library/solverinterface/#StochasticPrograms.solverstr-Tuple{AbstractSampledSolver}"><code>solverstr</code></a> to return an informative description string for printouts.</p><h3 id="Stochastic-programs"><a class="docs-heading-anchor" href="#Stochastic-programs">Stochastic programs</a><a id="Stochastic-programs-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-programs" title="Permalink"></a></h3><p>To interface a new structure-exploiting solver, define a shallow object of type <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredSolver"><code>AbstractStructuredSolver</code></a>. This object is intended to be the interface to end users of the solver and is what should be passed to <a href="../../library/public/#StochasticPrograms.optimize!-Tuple{StochasticModel,AbstractSampler}"><code>optimize!</code></a>. Define a new structured solver as a subtype of <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredModel"><code>AbstractStructuredModel</code></a>. Next, implement <a href="../../library/solverinterface/#StochasticPrograms.StructuredModel-Tuple{StochasticProgram,AbstractStructuredSolver}"><code>StructuredModel</code></a>, that takes the stochastic program and the <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredSolver"><code>AbstractStructuredSolver</code></a> object and return an instance of <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredModel"><code>AbstractStructuredModel</code></a> which internal state depends on the given stochastic program. Next, the solver algorithm should be run when calling <a href="../../library/solverinterface/#StochasticPrograms.optimize_structured!-Tuple{AbstractStructuredModel}"><code>optimize_structured!</code></a> on the <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredModel"><code>AbstractStructuredModel</code></a>. After successfuly optimizing the model, the solver must be able to fill in the optimal solution in the first stage and all second stages through <a href="../../library/solverinterface/#StochasticPrograms.fill_solution!-Tuple{StochasticProgram,AbstractStructuredModel}"><code>fill_solution!</code></a>.</p><p>In summary, the solver interface that a new <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredModel"><code>AbstractStructuredModel</code></a> and <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredSolver"><code>AbstractStructuredSolver</code></a> pair should adhere to is given by</p><ul><li><a href="../../library/solverinterface/#StochasticPrograms.StructuredModel-Tuple{StochasticProgram,AbstractStructuredSolver}"><code>StructuredModel</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.optimize_structured!-Tuple{AbstractStructuredModel}"><code>optimize_structured!</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.fill_solution!-Tuple{StochasticProgram,AbstractStructuredModel}"><code>fill_solution!</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.internal_solver-Tuple{AbstractSampledSolver}"><code>internal_solver</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.solverstr-Tuple{AbstractSampledSolver}"><code>solverstr</code></a></li></ul><p>As an example, a simplified version of the implementation of the structured solver interface for <a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.LShaped"><code>LShaped</code></a> is given below:</p><pre><code class="language-julia">abstract AbstractLShapedSolver &lt;: AbstractStructuredModel end

const MPB = MathProgBase

mutable struct LShapedSolver &lt;: AbstractStructuredSolver
    lpsolver::MPB.AbstractMathProgSolver
    subsolver::S
    feasibility_cuts::Bool
    execution::E
    regularize::R
    aggregate::A
    consolidate::C
    crash::CrashMethod
    parameters::Dict{Symbol,Any}

    function LShapedSolver(lpsolver::MPB.AbstractMathProgSolver;
                           execution::Execution = Serial(),
                           feasibility_cuts::Bool = true,
                           regularize::AbstractRegularizer = DontRegularize(),
                           aggregate::AbstractAggregator = DontAggregate(),
                           consolidate::AbstractConsolidator = DontConsolidate(),
                           crash::CrashMethod = Crash.None(),
                           subsolver::SubSolver = lpsolver, kwargs...)
        return new(lpsolver, subsolver, feasibility_cuts, execution, regularize, aggregate, consolidate, crash, Dict{Symbol,Any}(kwargs))
    end
end

function StructuredModel(stochasticprogram::StochasticProgram, solver::LShapedSolver)
    x₀ = solver.crash(stochasticprogram, solver.lpsolver)
    return LShaped(stochasticprogram, x₀, solver.lpsolver, get_solver(solver.subsolver), solver.feasibility_cuts, solver.execution, solver.regularize, solver.aggregate, solver.consolidate; solver.parameters...)
end

function internal_solver(solver::LShapedSolver)
    return solver.lpsolver
end

function optimize_structured!(lshaped::AbstractLShapedSolver)
    return lshaped()
end

function fill_solution!(stochasticprogram::StochasticProgram, lshaped::AbstractLShapedSolver)
    # First stage
    first_stage = StochasticPrograms.get_stage_one(stochasticprogram)
    nrows, ncols = first_stage_dims(stochasticprogram)
    StochasticPrograms.set_decision!(stochasticprogram, decision(lshaped))
    μ = try
        MPB.getreducedcosts(lshaped.mastersolver.lqmodel)[1:ncols]
    catch
        fill(NaN, ncols)
    end
    StochasticPrograms.set_first_stage_redcosts!(stochasticprogram, μ)
    λ = try
        MPB.getconstrduals(lshaped.mastersolver.lqmodel)[1:nrows]
    catch
        fill(NaN, nrows)
    end
    StochasticPrograms.set_first_stage_duals!(stochasticprogram, λ)
    # Second stage
    fill_submodels!(lshaped, scenarioproblems(stochasticprogram))
end

function solverstr(solver::LShapedSolver)
    return &quot;L-shaped solver&quot;
end</code></pre><h3 id="Stochastic-models"><a class="docs-heading-anchor" href="#Stochastic-models">Stochastic models</a><a id="Stochastic-models-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-models" title="Permalink"></a></h3><p>To interface a new sampled-based solver, define a shallow object of type <a href="../../library/solverinterface/#StochasticPrograms.AbstractSampledSolver"><code>AbstractSampledSolver</code></a>. This object is intended to be the interface to end users of the solver and is what should be passed to <a href="../../library/public/#StochasticPrograms.optimize!-Tuple{StochasticModel,AbstractSampler}"><code>optimize!</code></a>.Similar to finite programs, define a new sampled-based solver as a subtype of <a href="../../library/solverinterface/#StochasticPrograms.AbstractSampledModel"><code>AbstractSampledModel</code></a>. Next, implement <a href="../../library/solverinterface/#StochasticPrograms.SampledModel-Tuple{StochasticModel,AbstractSampledSolver}"><code>SampledModel</code></a>, that takes a stochastic model and the <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredSolver"><code>AbstractStructuredSolver</code></a> object and returns an instance of <a href="../../library/solverinterface/#StochasticPrograms.AbstractSampledModel"><code>AbstractSampledModel</code></a>. Next, the solver algorithm should be run when calling <a href="../../library/solverinterface/#StochasticPrograms.optimize_sampled!-Tuple{AbstractSampledModel,AbstractSampler,AbstractFloat}"><code>optimize_sampled!</code></a> on the <a href="../../library/solverinterface/#StochasticPrograms.AbstractSampledModel"><code>AbstractSampledModel</code></a>, some <a href="../../library/public/#StochasticPrograms.AbstractSampler"><code>AbstractSampler</code></a> and a desired confidence level. After successfuly optimizing the model, a <a href="../../library/public/#StochasticPrograms.StochasticSolution"><code>StochasticSolution</code></a> should be retrivable from the <a href="../../library/solverinterface/#StochasticPrograms.AbstractSampledModel"><code>AbstractSampledModel</code></a> using <a href="../../library/solverinterface/#StochasticPrograms.stochastic_solution-Tuple{AbstractSampledModel}"><code>stochastic_solution</code></a></p><p>In summary, the solver interface that a new <a href="../../library/solverinterface/#StochasticPrograms.AbstractSampledModel"><code>AbstractSampledModel</code></a> and <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredSolver"><code>AbstractStructuredSolver</code></a> pair should adhere to is given by</p><ul><li><a href="../../library/solverinterface/#StochasticPrograms.SampledModel-Tuple{StochasticModel,AbstractSampledSolver}"><code>SampledModel</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.optimize_sampled!-Tuple{AbstractSampledModel,AbstractSampler,AbstractFloat}"><code>optimize_sampled!</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.stochastic_solution-Tuple{AbstractSampledModel}"><code>stochastic_solution</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.internal_solver-Tuple{AbstractSampledSolver}"><code>internal_solver</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.solverstr-Tuple{AbstractSampledSolver}"><code>solverstr</code></a></li></ul><p>As an example, consider the implementation of <a href="../../library/public/#StochasticPrograms.SAA"><code>SAA</code></a>:</p><pre><code class="language-julia">struct SAA{S &lt;: SPSolverType} &lt;: AbstractStructuredSolver
    internal_solver::S

    function SAA(solver::SPSolverType)
        if isa(solver, JuMP.UnsetSolver)
            error(&quot;Cannot solve emerging SAA problems without functional solver.&quot;)
        end
        S = typeof(solver)
        return new{S}(solver)
    end
end
function SAA(; solver::SPSolverType = JuMP.UnsetSolver())
    return SAA(solver)
end

mutable struct SAAModel{M &lt;: StochasticModel, S &lt;: SPSolverType} &lt;: AbstractSampledModel
    stochasticmodel::M
    solver::S
    solution::StochasticSolution
end

function SampledModel(stochasticmodel::StochasticModel, solver::SAA)
    return SAAModel(stochasticmodel, solver.internal_solver, EmptySolution())
end

function optimize_sampled!(saamodel::SAAModel, sampler::AbstractSampler, confidence::AbstractFloat; M::Integer = 10, tol::AbstractFloat = 1e-1, Nmax::Integer = 5000)
    sm = saamodel.stochasticmodel
    solver = saamodel.solver
    n = 16
    α = 1-confidence
    while true
        CI = confidence_interval(sm, sampler; solver = solver, confidence = 1-α, N = N, M = M, Ñ = max(N, Ñ), T = T)
        Q = (upper(CI) + lower(CI))/2
        gap = length(CI)/abs(Q+1e-10)
        if gap &lt;= tol
            sp = sample(sm, sampler, N)
            optimize!(sp, solver = solver)
            Q = optimal_value(sp)
            while !(Q ∈ CI)
                sp = sample(sm, sampler, N)
                optimize!(sp, solver = solver)
                Q = optimal_value(sp)
            end
            saamodel.solution = StochasticSolution(optimal_decision(saa), Q, N, CI)
            saamodel.saa = saa
            return :Optimal
        end
        N = N * 2
        if N &gt; Nmax
            return :LimitReached
        end
        solver_config(solver, N)
    end
end

function stochastic_solution(saamodel::SAAModel)
    return saamodel.solution
end</code></pre><h2 id="L-shaped-solvers"><a class="docs-heading-anchor" href="#L-shaped-solvers">L-shaped solvers</a><a id="L-shaped-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#L-shaped-solvers" title="Permalink"></a></h2><p>StochasticPrograms includes a collection of L-shaped algorithms in the submodule <code>LShapedSolvers</code>. All algorithm variants are based on the L-shaped method by Van Slyke and Wets. <code>LShapedSolvers</code> interfaces with StochasticPrograms through the structured solver interface. Every algorithm variant is an instance of the functor object <a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.LShaped"><code>LShaped</code></a>, and are instanced using the factory object <a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.LShapedSolver"><code>LShapedSolver</code></a>.</p><p>As an example, we solve the simple problem introduced in the <a href="../quickstart/#Quick-start">Quick start</a>:</p><pre><code class="language-julia">using LShapedSolvers
using GLPKMathProgInterface

optimize!(sp, solver = LShapedSolver(GLPKSolverLP()))</code></pre><pre><code class="language-julia">L-Shaped Gap  Time: 0:00:01 (6 iterations)
  Objective:       -855.8333333333358
  Gap:             0.0
  Number of cuts:  8
:Optimal</code></pre><p>Note, that an LP capable <code>AbstractMathProgSolver</code> is required to solve emerging subproblems.</p><p><code>LShapedSolvers</code> uses a policy-based design. This allows combinatorially many variants of the original algorithm to be instanced by supplying linearly many policies to the factory function <a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.LShapedSolver"><code>LShapedSolver</code></a>. We briefly describe the various policies in the following.</p><h3 id="Feasibility-cuts"><a class="docs-heading-anchor" href="#Feasibility-cuts">Feasibility cuts</a><a id="Feasibility-cuts-1"></a><a class="docs-heading-anchor-permalink" href="#Feasibility-cuts" title="Permalink"></a></h3><p>If the stochastic program does not have complete, or relatively complete, recourse then subproblems may be infeasible for some master iterates. Convergence can be maintained through the use of feasibility cuts. To reduce overhead and memory usage, feasibility issues are ignored by default. If you know that your problem does not have complete recourse, or if the algorithm terminates due to infeasibility, supply <code>feasibility_cuts = true</code> to the factory function to turn on this feature.</p><h3 id="Regularization"><a class="docs-heading-anchor" href="#Regularization">Regularization</a><a id="Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Regularization" title="Permalink"></a></h3><p>A Regularization procedure can improve algorithm performance. The idea is to limit the candidate search to a neighborhood of the current best iterate in the master problem. This can result in more effective cutting planes. Moreover, regularization enables warm-starting the L-shaped procedure with <a href="../../library/crash/#StochasticPrograms.Crash"><code>Crash</code></a> decisions. Regularization is enabled by supplying a factory object through <code>regularize</code> to <a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.LShapedSolver"><code>LShapedSolver</code></a>.</p><p>The following L-shaped regularizations are available:</p><ul><li><a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.NoRegularization"><code>NoRegularization</code></a> (default)</li><li><a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.RegularizedDecomposition"><code>RegularizedDecomposition</code></a></li><li><a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.TrustRegion"><code>TrustRegion</code></a></li><li><a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.LevelSet"><code>LevelSet</code></a></li></ul><p>Note, that <a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.RegularizedDecomposition"><code>RegularizedDecomposition</code></a> and <a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.LevelSet"><code>LevelSet</code></a> require an <code>AbstractMathProgSolver</code> capable of solving QP problems. Alternatively, the 2-norm penalty term in the objective can be approximated through various linear terms. This is achieved by supplying a <code>PenaltyTerm</code> object through <code>penaltyterm</code> in either <a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.RD"><code>RD</code></a> or <a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.LV"><code>LV</code></a>. The alternatives are given below:</p><ul><li><a href="../../library/solverinterface/#StochasticPrograms.Quadratic"><code>Quadratic</code></a> (default)</li><li><a href="../../library/solverinterface/#StochasticPrograms.Linearized"><code>Linearized</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.InfNorm"><code>InfNorm</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.ManhattanNorm"><code>ManhattanNorm</code></a></li></ul><h3 id="Aggregation"><a class="docs-heading-anchor" href="#Aggregation">Aggregation</a><a id="Aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregation" title="Permalink"></a></h3><p>Cut aggregation can be applied to reduce communication latency and load imbalance. This can yield major performance improvements in distributed settings. Aggregation is enabled by supplying a factory object through <code>aggregate</code> to the factory function.</p><p>The following aggregation schemes are available:</p><ul><li><a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.NoAggregation"><code>NoAggregation</code></a> (default)</li><li><a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.PartialAggregation"><code>PartialAggregation</code></a></li><li><a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.DynamicAggregation"><code>DynamicAggregation</code></a></li><li><a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.ClusterAggregation"><code>ClusterAggregation</code></a></li><li><a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.HybridAggregation"><code>HybridAggregation</code></a></li></ul><h3 id="Consolidation"><a class="docs-heading-anchor" href="#Consolidation">Consolidation</a><a id="Consolidation-1"></a><a class="docs-heading-anchor-permalink" href="#Consolidation" title="Permalink"></a></h3><p>If cut consolidation is enabled, cuts from previous iterations that are no longer active are aggregated to reduce the size of the master. Consolidation is enabled by supplying <code>consolidate = Consolidate()</code> to the factory function. See <a href="../../library/lshaped/#StochasticPrograms.LShapedSolvers.Consolidation"><code>Consolidation</code></a> for further details.</p><h3 id="Crash"><a class="docs-heading-anchor" href="#Crash">Crash</a><a id="Crash-1"></a><a class="docs-heading-anchor-permalink" href="#Crash" title="Permalink"></a></h3><p>The L-shaped algorithm can be crash started in various way. A good initial guess in combination with a regularization procedure can improve convergence.</p><p>The following <a href="../../library/crash/#StochasticPrograms.Crash"><code>Crash</code></a> methods can be used through the <code>crash</code> option in the factory function.</p><ul><li><a href="../../library/crash/#StochasticPrograms.Crash.None"><code>Crash.None</code></a> (default)</li><li><a href="../../library/crash/#StochasticPrograms.Crash.EVP"><code>Crash.EVP</code></a></li><li><a href="../../library/crash/#StochasticPrograms.Crash.Scenario"><code>Crash.Scenario</code></a></li><li><a href="../../library/crash/#StochasticPrograms.Crash.Custom"><code>Crash.Custom</code></a></li></ul><h3 id="Execution"><a class="docs-heading-anchor" href="#Execution">Execution</a><a id="Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Execution" title="Permalink"></a></h3><p>There are three available modes of execution:</p><ul><li><a href="../../library/solverinterface/#StochasticPrograms.Serial"><code>Serial</code></a> (default)</li><li><a href="../../library/solverinterface/#StochasticPrograms.Synchronous"><code>Synchronous</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.Asynchronous"><code>Asynchronous</code></a></li></ul><p>Running a distributed L-shaped algorithm, either synchronously or asynchronously, required adding Julia worker cores with [<code>addprocs</code>].</p><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><ol><li><p>Van Slyke, R. and Wets, R. (1969), <a href="https://epubs.siam.org/doi/abs/10.1137/0117061">L-Shaped Linear Programs with Applications to Optimal Control and Stochastic Programming</a>, SIAM Journal on Applied Mathematics, vol. 17, no. 4, pp. 638-663.</p></li><li><p>Ruszczyński, A (1986), <a href="https://link.springer.com/article/10.1007/BF01580883">A regularized decomposition method for minimizing a sum of polyhedral functions</a>, Mathematical Programming, vol. 35, no. 3, pp. 309-333.</p></li><li><p>Linderoth, J. and Wright, S. (2003), <a href="https://link.springer.com/article/10.1023/A:1021858008222">Decomposition Algorithms for Stochastic Programming on a Computational Grid</a>, Computational Optimization and Applications, vol. 24, no. 2-3, pp. 207-250.</p></li><li><p>Fábián, C. and Szőke, Z. (2006), <a href="https://link.springer.com/article/10.1007%2Fs10287-006-0026-8">Solving two-stage stochastic programming problems with level decomposition</a>, Computational Management Science, vol. 4, no. 4, pp. 313-353.</p></li><li><p>Wolf, C. and Koberstein, A. (2013), <a href="https://www.sciencedirect.com/science/article/pii/S0377221713003159">Dynamic sequencing and cut con-solidation for the parallel hybrid-cut nested l-shaped method</a>, European Journal of Operational Research, vol. 230, no. 1, pp. 143-156.</p></li><li><p>Biel, M. and Johansson, M. (2018), <a href="https://ieeexplore.ieee.org/document/8639173">Distributed L-shaped Algorithms in Julia</a>, 2018 IEEE/ACM Parallel Applications Workshop, Alternatives To MPI (PAW-ATM).</p></li><li><p>Biel, M. and Johansson, M. (2019), <a href="https://arxiv.org/abs/1910.13752">Dynamic cut aggregation in L-shaped algorithms</a>, arXiv preprint arXiv:1910.13752.</p></li></ol><h2 id="ProgressiveHedgingSolvers.jl"><a class="docs-heading-anchor" href="#ProgressiveHedgingSolvers.jl">ProgressiveHedgingSolvers.jl</a><a id="ProgressiveHedgingSolvers.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ProgressiveHedgingSolvers.jl" title="Permalink"></a></h2><p>StochasticPrograms also includes a collection of progressive-hedging algorithms in the submodule <code>ProgressiveHedgingSolvers</code>. All algorithm variants are based on the original progressive-hedging algorithm by Rockafellar and Wets. <code>ProgressiveHedgingSolvers</code> interfaces with StochasticPrograms through the structured solver interface. Every algorithm variant is an instance of the functor object <a href="../../library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.ProgressiveHedging"><code>ProgressiveHedging</code></a>, and are instanced using the factory object <a href="../../library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.ProgressiveHedgingSolver"><code>ProgressiveHedgingSolver</code></a>.</p><p>As an example, we solve the simple problem introduced in the <a href="../quickstart/#Quick-start">Quick start</a>:</p><pre><code class="language-julia">using ProgressiveHedgingSolvers
using GLPKMathProgInterface

optimize!(sp, solver = ProgressiveHedgingSolver(GLPKSolverLP, penaltyterm = Linearized(nbreakpoints=30))</code></pre><pre><code class="language-julia">Progressive Hedging Time: 0:00:00 (91 iterations)
  Objective:  -855.8017375415484
  δ:          9.700002687897287e-6
:Optimal</code></pre><p>Note, that an QP/LP capable <code>AbstractMathProgSolver</code> is required to solve emerging subproblems.</p><p><code>ProgressiveHedgingSolvers</code> also uses a policy-based design. See <a href="../../library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.ProgressiveHedgingSolver"><code>ProgressiveHedgingSolver</code></a> for options. We briefly describe the various policies in the following.</p><h3 id="Penalty"><a class="docs-heading-anchor" href="#Penalty">Penalty</a><a id="Penalty-1"></a><a class="docs-heading-anchor-permalink" href="#Penalty" title="Permalink"></a></h3><p>There are two options for the penalty parameter used in the progressive-hedging algorithm. The alternatives are</p><ul><li><a href="../../library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.Fixed"><code>Fixed</code></a> (default)</li><li><a href="../../library/progressivehedging/#StochasticPrograms.ProgressiveHedgingSolvers.Adaptive"><code>Adaptive</code></a></li></ul><h3 id="Execution-2"><a class="docs-heading-anchor" href="#Execution-2">Execution</a><a class="docs-heading-anchor-permalink" href="#Execution-2" title="Permalink"></a></h3><p>The same execution policies as for <code>LShapedSolvers</code> are available in <code>ProgressiveHedgingSolvers</code>, i.e.</p><ul><li><a href="../../library/solverinterface/#StochasticPrograms.Serial"><code>Serial</code></a> (default)</li><li><a href="../../library/solverinterface/#StochasticPrograms.Synchronous"><code>Synchronous</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.Asynchronous"><code>Asynchronous</code></a></li></ul><h3 id="Penalty-term"><a class="docs-heading-anchor" href="#Penalty-term">Penalty term</a><a id="Penalty-term-1"></a><a class="docs-heading-anchor-permalink" href="#Penalty-term" title="Permalink"></a></h3><p>As with the L-shaped variants with quadratic 2-norm terms, the 2-norm term in progressive-hedging subproblems can be approximated. This enables the use of <code>AbstractMathProgSolver</code> that only solve linear problems. The alternatives are as before:</p><ul><li><a href="../../library/solverinterface/#StochasticPrograms.Quadratic"><code>Quadratic</code></a> (default)</li><li><a href="../../library/solverinterface/#StochasticPrograms.Linearized"><code>Linearized</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.InfNorm"><code>InfNorm</code></a></li><li><a href="../../library/solverinterface/#StochasticPrograms.ManhattanNorm"><code>ManhattanNorm</code></a></li></ul><h3 id="References-2"><a class="docs-heading-anchor" href="#References-2">References</a><a class="docs-heading-anchor-permalink" href="#References-2" title="Permalink"></a></h3><ol><li><p>R. T. Rockafellar and Roger J.-B. Wets (1991), <a href="https://pubsonline.informs.org/doi/10.1287/moor.16.1.119">Scenarios and Policy Aggregation in Optimization Under Uncertainty</a>, Mathematics of Operations Research, vol. 16, no. 1, pp. 119-147.</p></li><li><p>Zehtabian. S and Bastin. F (2016), <a href="http://www.cirrelt.ca/DocumentsTravail/CIRRELT-2016-12.pdf">Penalty parameter update strategies in progressive hedging algorithm</a></p></li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../distributed/">« Distributed stochastic programs</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 14 July 2020 09:32">Tuesday 14 July 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
